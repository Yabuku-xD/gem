import org.antlr.v4.runtime.tree.ParseTree;
import org.objectweb.asm.*;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

public class CodeGenerator {
    private GemSemanticAnalyzer semanticAnalyzer;
    private Map<String, Integer> localVars = new HashMap<>();
    private Map<String, String> definedVariables = new HashMap<>();
    private int nextVarIndex = 1;
    private Label currentBreakLabel = null;

    public CodeGenerator() {
        this.definedVariables = new HashMap<>();
    }

    public void generate(ParseTree tree, GemSemanticAnalyzer analyzer, String className, String outputFile) {
        this.semanticAnalyzer = analyzer;

        for (Map.Entry<String, String> entry : analyzer.getAllVariableTypes().entrySet()) {
            definedVariables.put(entry.getKey(), entry.getValue());
        }

        try {
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

            cw.visit(
                    Opcodes.V20,
                    Opcodes.ACC_PUBLIC,
                    className,
                    null,
                    "java/lang/Object",
                    null
            );

            MethodVisitor constructor = cw.visitMethod(
                    Opcodes.ACC_PUBLIC,
                    "<init>",
                    "()V",
                    null,
                    null
            );
            constructor.visitCode();
            constructor.visitVarInsn(Opcodes.ALOAD, 0);
            constructor.visitMethodInsn(
                    Opcodes.INVOKESPECIAL,
                    "java/lang/Object",
                    "<init>",
                    "()V",
                    false
            );
            constructor.visitInsn(Opcodes.RETURN);
            constructor.visitMaxs(1, 1);
            constructor.visitEnd();

            MethodVisitor mv = cw.visitMethod(
                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
                    "main",
                    "([Ljava/lang/String;)V",
                    null,
                    null
            );
            mv.visitCode();

            localVars.put("args", 0);

            generateProgram((gemParser.ProgramContext)tree, mv);

            mv.visitInsn(Opcodes.RETURN);
            mv.visitMaxs(0, 0); // Will be auto-computed
            mv.visitEnd();

            cw.visitEnd();

            try (FileOutputStream fos = new FileOutputStream(outputFile)) {
                fos.write(cw.toByteArray());
            }

            System.out.println("Successfully generated bytecode: " + outputFile);
        } catch (IOException e) {
            System.err.println("Error generating bytecode: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void generateProgram(gemParser.ProgramContext ctx, MethodVisitor mv) {
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }
    }

    private void generateBreakStatement(gemParser.BreakStatementContext ctx, MethodVisitor mv) {
        if (currentBreakLabel == null) {
            throw new UnsupportedOperationException("Break statement not in a loop");
        }
        mv.visitJumpInsn(Opcodes.GOTO, currentBreakLabel);
    }

    private void generateStatement(gemParser.StatementContext ctx, MethodVisitor mv) {
        if (ctx.variableDeclaration() != null) {
            generateVariableDeclaration(ctx.variableDeclaration(), mv);
        } else if (ctx.assignment() != null) {
            generateAssignment(ctx.assignment(), mv);
        } else if (ctx.ifStatement() != null) {
            generateIfStatement(ctx.ifStatement(), mv);
        } else if (ctx.forLoop() != null) {
            generateForLoop(ctx.forLoop(), mv);
        } else if (ctx.whileLoop() != null) {
            generateWhileLoop(ctx.whileLoop(), mv);
        } else if (ctx.loop() != null) {
            generateLoop(ctx.loop(), mv);
        } else if (ctx.printStatement() != null) {
            generatePrintStatement(ctx.printStatement(), mv);
        } else if (ctx.readStatement() != null) {
            generateReadStatement(ctx.readStatement(), mv);
        } else if (ctx.expression() != null) {
            generateExpression(ctx.expression(), mv);
            mv.visitInsn(Opcodes.POP);
        } else if (ctx.functionCall() != null) {
            String functionName = ctx.functionCall().ID(0).getText();
            if (functionName.equals("read_integer")) {
                generateIntegerInputWithErrorHandling(mv);
            } else if (functionName.equals("read_line")) {

                mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
                mv.visitInsn(Opcodes.DUP);
                mv.visitFieldInsn(
                        Opcodes.GETSTATIC,
                        "java/lang/System",
                        "in",
                        "Ljava/io/InputStream;"
                );
                mv.visitMethodInsn(
                        Opcodes.INVOKESPECIAL,
                        "java/util/Scanner",
                        "<init>",
                        "(Ljava/io/InputStream;)V",
                        false
                );

                if (functionName.equals("read_line")) {
                    mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/util/Scanner",
                            "nextLine",
                            "()Ljava/lang/String;",
                            false
                    );
                } else if (functionName.equals("read_integer")) {
                    mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/util/Scanner",
                            "nextInt",
                            "()I",
                            false
                    );
                }
            } else {
                throw new UnsupportedOperationException("Function calls not supported in this version");
            }
        }  else if (ctx.innerFunctionDeclaration() != null || ctx.returnStatement() != null) {
            throw new UnsupportedOperationException("Functions not supported in this version");
        } else if (ctx.breakStatement() != null) {
            generateBreakStatement(ctx.breakStatement(), mv);
        } else {
            throw new UnsupportedOperationException("Unsupported statement type");
        }
    }

    private void generateVariableDeclaration(gemParser.VariableDeclarationContext ctx, MethodVisitor mv) {
        if (ctx.struct_type() != null || ctx.class_type() != null) {
            throw new UnsupportedOperationException("Composite types not supported in this version");
        }

        String varName = ctx.ID().getText();
        String typeName = getTypeString(ctx.type());

        int varIndex = nextVarIndex++;
        localVars.put(varName, varIndex);

        if (ctx.expression() != null) {
            generateExpression(ctx.expression(), mv);
            storeVariable(varName, typeName, mv);
        } else {
            switch(typeName) {
                case "integer", "boolean" -> {
                    mv.visitInsn(Opcodes.ICONST_0);
                    mv.visitVarInsn(Opcodes.ISTORE, varIndex);
                }
                case "number" -> {
                    mv.visitInsn(Opcodes.FCONST_0);
                    mv.visitVarInsn(Opcodes.FSTORE, varIndex);
                }
                case "string" -> {
                    mv.visitInsn(Opcodes.ACONST_NULL);
                    mv.visitVarInsn(Opcodes.ASTORE, varIndex);
                }
                default -> throw new UnsupportedOperationException("Unsupported variable type: " + typeName);
            }
        }
    }

    private void generateAssignment(gemParser.AssignmentContext ctx, MethodVisitor mv) {
        if (ctx.ID().size() > 1 || ctx.LBRACK() != null) {
            throw new UnsupportedOperationException("Field and array assignments not supported in this version");
        }

        String varName = ctx.ID(0).getText();
        String typeName = semanticAnalyzer.getVariableType(varName);

        generateExpression(ctx.expression(0), mv);
        storeVariable(varName, typeName, mv);
    }

    private void generateIfStatement(gemParser.IfStatementContext ctx, MethodVisitor mv) {
        if (ctx.THEN() != null) {
            Label endLabel = new Label();

            generateExpression(ctx.expression(0), mv);
            mv.visitJumpInsn(Opcodes.IFEQ, endLabel);

            gemParser.StatementContext thenStmt = ctx.statement(0);
            if (thenStmt.breakStatement() != null) {
                if (currentBreakLabel == null) {
                    throw new UnsupportedOperationException("Break statement not in a loop");
                }
                mv.visitJumpInsn(Opcodes.GOTO, currentBreakLabel);
            } else {
                generateStatement(thenStmt, mv);
            }

            if (ctx.ELSE() != null && ctx.statement().size() > 1) {
                Label afterElseLabel = new Label();
                mv.visitJumpInsn(Opcodes.GOTO, afterElseLabel);
                mv.visitLabel(endLabel);

                gemParser.StatementContext elseStmt = ctx.statement(1);
                if (elseStmt.breakStatement() != null) {
                    if (currentBreakLabel == null) {
                        throw new UnsupportedOperationException("Break statement not in a loop");
                    }
                    mv.visitJumpInsn(Opcodes.GOTO, currentBreakLabel);
                } else {
                    generateStatement(elseStmt, mv);
                }

                mv.visitLabel(afterElseLabel);
            } else {
                mv.visitLabel(endLabel);
            }
        } else {
            Label endLabel = new Label();

            int originalVarCount = nextVarIndex;
            Map<String, Integer> originalVars = new HashMap<>(localVars);

            int numExpressions = ctx.expression().size();
            Label[] falseLabels = new Label[numExpressions];

            List<Integer> branchStarts = new ArrayList<>();
            List<Integer> branchEnds = new ArrayList<>();

            int currentPos = 0;
            for (int i = 0; i < ctx.getChildCount(); i++) {
                if (ctx.getChild(i) instanceof gemParser.ExpressionContext) {
                    branchStarts.add(currentPos);
                } else if (ctx.getChild(i) instanceof gemParser.StatementContext) {
                    currentPos++;
                } else if (ctx.getChild(i).getText().equals("else") &&
                        (i + 1 < ctx.getChildCount() && !ctx.getChild(i + 1).getText().equals("if"))) {
                    branchStarts.add(currentPos);
                    break;
                }
            }

            for (int i = 0; i < branchStarts.size() - 1; i++) {
                branchEnds.add(branchStarts.get(i + 1));
            }
            branchEnds.add(ctx.statement().size());

            for (int i = 0; i < numExpressions; i++) {
                nextVarIndex = originalVarCount;
                localVars = new HashMap<>(originalVars);

                falseLabels[i] = new Label();

                generateExpression(ctx.expression(i), mv);
                mv.visitJumpInsn(Opcodes.IFEQ, falseLabels[i]);

                int startStmt = branchStarts.get(i);
                int endStmt = branchEnds.get(i);

                for (int j = startStmt; j < endStmt; j++) {
                    generateStatement(ctx.statement(j), mv);
                }

                mv.visitJumpInsn(Opcodes.GOTO, endLabel);

                mv.visitLabel(falseLabels[i]);
            }

            if (ctx.ELSE() != null && branchStarts.size() > numExpressions) {
                nextVarIndex = originalVarCount;
                localVars = new HashMap<>(originalVars);

                int startStmt = branchStarts.get(branchStarts.size() - 1);
                int endStmt = branchEnds.get(branchEnds.size() - 1);

                for (int j = startStmt; j < endStmt; j++) {
                    generateStatement(ctx.statement(j), mv);
                }
            }

            nextVarIndex = originalVarCount;
            localVars = originalVars;

            mv.visitLabel(endLabel);
        }
    }

    private void generateForLoop(gemParser.ForLoopContext ctx, MethodVisitor mv) {
        String loopVar = ctx.ID().getText();
        int varIndex = nextVarIndex++;
        localVars.put(loopVar, varIndex);

        String loopVarType = semanticAnalyzer.getVariableType(loopVar);
        if (loopVarType == null) {
            loopVarType = "integer";
        }

        if (!definedVariables.containsKey(loopVar)) {
            definedVariables.put(loopVar, loopVarType);
        }

        Label loopStart = new Label();
        Label loopEnd = new Label();

        Label prevBreakLabel = currentBreakLabel;
        currentBreakLabel = loopEnd;

        generateExpression(ctx.expression(0), mv);
        mv.visitVarInsn(Opcodes.ISTORE, varIndex);

        mv.visitLabel(loopStart);
        mv.visitVarInsn(Opcodes.ILOAD, varIndex);
        generateExpression(ctx.expression(1), mv);
        mv.visitJumpInsn(Opcodes.IF_ICMPGT, loopEnd);

        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        mv.visitIincInsn(varIndex, 1);
        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        mv.visitLabel(loopEnd);
        currentBreakLabel = prevBreakLabel;
    }

    private void generateWhileLoop(gemParser.WhileLoopContext ctx, MethodVisitor mv) {
        Label loopStart = new Label();
        Label loopEnd = new Label();

        Label prevBreakLabel = currentBreakLabel;
        currentBreakLabel = loopEnd;

        mv.visitLabel(loopStart);
        generateExpression(ctx.expression(), mv);
        mv.visitJumpInsn(Opcodes.IFEQ, loopEnd);

        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        mv.visitLabel(loopEnd);
        currentBreakLabel = prevBreakLabel;
    }

    private void generateLoop(gemParser.LoopContext ctx, MethodVisitor mv) {
        Label loopStart = new Label();
        Label loopEnd = new Label();

        Label prevBreakLabel = currentBreakLabel;
        currentBreakLabel = loopEnd;

        mv.visitLabel(loopStart);

        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        mv.visitLabel(loopEnd);
        currentBreakLabel = prevBreakLabel;
    }

    private void generatePrintStatement(gemParser.PrintStatementContext ctx, MethodVisitor mv) {
        mv.visitFieldInsn(
                Opcodes.GETSTATIC,
                "java/lang/System",
                "out",
                "Ljava/io/PrintStream;"
        );

        String exprType = getExpressionType(ctx.expression());

        if (isConcatenation(ctx.expression())) {
            generateStringConcatenation(ctx.expression(), mv);
        } else {
            generateExpression(ctx.expression(), mv);

            if (!exprType.equals("string")) {
                switch(exprType) {
                    case "integer" -> mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            "java/lang/String",
                            "valueOf",
                            "(I)Ljava/lang/String;",
                            false
                    );
                    case "number" -> mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            "java/lang/String",
                            "valueOf",
                            "(F)Ljava/lang/String;",
                            false
                    );
                    case "boolean" -> mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            "java/lang/String",
                            "valueOf",
                            "(Z)Ljava/lang/String;",
                            false
                    );
                    default -> throw new UnsupportedOperationException("Cannot print type: " + exprType);
                }
            }
        }

        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/io/PrintStream",
                "println",
                "(Ljava/lang/String;)V",
                false
        );
    }

    private boolean isConcatenation(gemParser.ExpressionContext ctx) {
        gemParser.ComparisonExpressionContext compCtx = ctx.logicalExpression().comparisonExpression(0);
        gemParser.AdditiveExpressionContext addCtx = compCtx.additiveExpression(0);
        return addCtx.multiplicativeExpression().size() > 1 && addCtx.PLUS().size() > 0;
    }

    private void generateStringConcatenation(gemParser.ExpressionContext ctx, MethodVisitor mv) {
        mv.visitTypeInsn(Opcodes.NEW, "java/lang/StringBuilder");
        mv.visitInsn(Opcodes.DUP);
        mv.visitMethodInsn(
                Opcodes.INVOKESPECIAL,
                "java/lang/StringBuilder",
                "<init>",
                "()V",
                false
        );

        gemParser.ComparisonExpressionContext compCtx = ctx.logicalExpression().comparisonExpression(0);
        gemParser.AdditiveExpressionContext addCtx = compCtx.additiveExpression(0);

        String firstType = getMultiplicativeExpressionType(addCtx.multiplicativeExpression(0));
        generateMultiplicativeExpression(addCtx.multiplicativeExpression(0), mv);

        appendToStringBuilder(mv, firstType);

        for (int i = 1; i < addCtx.multiplicativeExpression().size(); i++) {
            String opType = getMultiplicativeExpressionType(addCtx.multiplicativeExpression(i));
            generateMultiplicativeExpression(addCtx.multiplicativeExpression(i), mv);

            appendToStringBuilder(mv, opType);
        }

        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/StringBuilder",
                "toString",
                "()Ljava/lang/String;",
                false
        );
    }

    private void appendToStringBuilder(MethodVisitor mv, String type) {
        String descriptor;
        switch (type) {
            case "integer" -> descriptor = "(I)Ljava/lang/StringBuilder;";
            case "number" -> descriptor = "(F)Ljava/lang/StringBuilder;";
            case "boolean" -> descriptor = "(Z)Ljava/lang/StringBuilder;";
            case "string" -> descriptor = "(Ljava/lang/String;)Ljava/lang/StringBuilder;";
            default -> descriptor = "(Ljava/lang/Object;)Ljava/lang/StringBuilder;";
        }

        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/StringBuilder",
                "append",
                descriptor,
                false
        );
    }

    private void generateReadStatement(gemParser.ReadStatementContext ctx, MethodVisitor mv) {
        String funcName = ctx.ID().getText();

        if (funcName.equals("read_integer")) {
            generateIntegerInputWithErrorHandling(mv);
        } else if (funcName.equals("read_line")) {
            mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
            mv.visitInsn(Opcodes.DUP);
            mv.visitFieldInsn(
                    Opcodes.GETSTATIC,
                    "java/lang/System",
                    "in",
                    "Ljava/io/InputStream;"
            );
            mv.visitMethodInsn(
                    Opcodes.INVOKESPECIAL,
                    "java/util/Scanner",
                    "<init>",
                    "(Ljava/io/InputStream;)V",
                    false
            );
            mv.visitMethodInsn(
                    Opcodes.INVOKEVIRTUAL,
                    "java/util/Scanner",
                    "nextLine",
                    "()Ljava/lang/String;",
                    false
            );
        } else {
            throw new UnsupportedOperationException("Unsupported read function: " + funcName);
        }
    }

    private void generateExpression(gemParser.ExpressionContext ctx, MethodVisitor mv) {
        generateLogicalExpression(ctx.logicalExpression(), mv);
    }

    private void generateLogicalExpression(gemParser.LogicalExpressionContext ctx, MethodVisitor mv) {
        if (ctx.comparisonExpression().size() == 1) {
            generateComparisonExpression(ctx.comparisonExpression(0), mv);
            return;
        }

        generateComparisonExpression(ctx.comparisonExpression(0), mv);

        for (int i = 0; i < ctx.getChildCount() / 2; i++) {
            String operator = ctx.getChild(i * 2 + 1).getText();

            if (operator.equals("and")) {
                Label falseLabel = new Label();
                Label endLabel = new Label();

                mv.visitJumpInsn(Opcodes.IFEQ, falseLabel);

                generateComparisonExpression(ctx.comparisonExpression(i + 1), mv);
                mv.visitJumpInsn(Opcodes.GOTO, endLabel);

                mv.visitLabel(falseLabel);
                mv.visitInsn(Opcodes.ICONST_0);

                mv.visitLabel(endLabel);
            } else if (operator.equals("or")) {
                Label trueLabel = new Label();
                Label endLabel = new Label();

                mv.visitJumpInsn(Opcodes.IFNE, trueLabel);

                generateComparisonExpression(ctx.comparisonExpression(i + 1), mv);
                mv.visitJumpInsn(Opcodes.GOTO, endLabel);

                mv.visitLabel(trueLabel);
                mv.visitInsn(Opcodes.ICONST_1);

                mv.visitLabel(endLabel);
            }
        }
    }

    private void generateComparisonExpression(gemParser.ComparisonExpressionContext ctx, MethodVisitor mv) {
        if (ctx.additiveExpression().size() == 1) {
            generateAdditiveExpression(ctx.additiveExpression(0), mv);
            return;
        }

        String leftType = getExpressionType(ctx.additiveExpression(0));
        String rightType = getExpressionType(ctx.additiveExpression(1));

        generateAdditiveExpression(ctx.additiveExpression(0), mv);
        generateAdditiveExpression(ctx.additiveExpression(1), mv);

        String op = ctx.getChild(1).getText();
        Label trueLabel = new Label();
        Label endLabel = new Label();

        if ("string".equals(leftType) && "string".equals(rightType)) {
            if ("==".equals(op)) {
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "equals", "(Ljava/lang/Object;)Z", false);
                mv.visitJumpInsn(Opcodes.IFNE, trueLabel);
            } else if ("!=".equals(op)) {
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "equals", "(Ljava/lang/Object;)Z", false);
                mv.visitJumpInsn(Opcodes.IFEQ, trueLabel);
            } else {
                throw new UnsupportedOperationException("Unsupported string comparison operator: " + op);
            }
        } else {
            switch (op) {
                case "<" -> mv.visitJumpInsn(Opcodes.IF_ICMPLT, trueLabel);
                case ">" -> mv.visitJumpInsn(Opcodes.IF_ICMPGT, trueLabel);
                case "<=" -> mv.visitJumpInsn(Opcodes.IF_ICMPLE, trueLabel);
                case ">=" -> mv.visitJumpInsn(Opcodes.IF_ICMPGE, trueLabel);
                case "==" -> mv.visitJumpInsn(Opcodes.IF_ICMPEQ, trueLabel);
                case "!=" -> mv.visitJumpInsn(Opcodes.IF_ICMPNE, trueLabel);
                default -> throw new UnsupportedOperationException("Unsupported comparison operator: " + op);
            }
        }

        mv.visitInsn(Opcodes.ICONST_0);
        mv.visitJumpInsn(Opcodes.GOTO, endLabel);

        mv.visitLabel(trueLabel);
        mv.visitInsn(Opcodes.ICONST_1);

        mv.visitLabel(endLabel);
    }

    private void generateAdditiveExpression(gemParser.AdditiveExpressionContext ctx, MethodVisitor mv) {
        if (ctx.multiplicativeExpression().size() == 1) {
            generateMultiplicativeExpression(ctx.multiplicativeExpression(0), mv);
            return;
        }

        generateMultiplicativeExpression(ctx.multiplicativeExpression(0), mv);

        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            generateMultiplicativeExpression(ctx.multiplicativeExpression(i), mv);

            String op = ctx.getChild(i * 2 - 1).getText();
            if (op.equals("+")) {
                mv.visitInsn(Opcodes.IADD);
            } else if (op.equals("-")) {
                mv.visitInsn(Opcodes.ISUB);
            }
        }
    }

    private void generateMultiplicativeExpression(gemParser.MultiplicativeExpressionContext ctx, MethodVisitor mv) {
        generateMessageExpression(ctx.messageExpression(0), mv);

        for (int i = 1; i < ctx.messageExpression().size(); i++) {
            generateMessageExpression(ctx.messageExpression(i), mv);

            String op = ctx.getChild(i * 2 - 1).getText();
            switch (op) {
                case "*" -> mv.visitInsn(Opcodes.IMUL);
                case "/" -> mv.visitInsn(Opcodes.IDIV);
                case "%" -> mv.visitInsn(Opcodes.IREM);
                default -> throw new UnsupportedOperationException("Unsupported multiplicative operator: " + op);
            }
        }
    }

    private void generateMessageExpression(gemParser.MessageExpressionContext ctx, MethodVisitor mv) {
        if (ctx.ARROW() != null || (ctx.DOT() != null && ctx.LPAREN() != null) || ctx.LBRACK() != null) {
            throw new UnsupportedOperationException("Message passing, method calls, and arrays not supported in this version");
        }

        if (ctx.DOT() != null) {
            throw new UnsupportedOperationException("Field access not supported in this version");
        }

        generatePrimaryExpression(ctx.primaryExpression(), mv);
    }

    private void generatePrimaryExpression(gemParser.PrimaryExpressionContext ctx, MethodVisitor mv) {
        if (ctx.ID() != null && ctx.LPAREN() == null) {
            String varName = ctx.ID().getText();
            String varType = semanticAnalyzer.getVariableType(varName);
            loadVariable(varName, varType, mv);
        } else if (ctx.literal() != null) {
            generateLiteral(ctx.literal(), mv);
        } else if (ctx.expression() != null) {
            generateExpression(ctx.expression(), mv);
        } else if (ctx.ID() != null && ctx.LPAREN() != null) {
            String functionName = ctx.ID().getText();
            if (functionName.equals("read_integer")) {
                generateIntegerInputWithErrorHandling(mv);
            } else if (functionName.equals("read_line")) {
                mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
                mv.visitInsn(Opcodes.DUP);
                mv.visitFieldInsn(
                        Opcodes.GETSTATIC,
                        "java/lang/System",
                        "in",
                        "Ljava/io/InputStream;"
                );
                mv.visitMethodInsn(
                        Opcodes.INVOKESPECIAL,
                        "java/util/Scanner",
                        "<init>",
                        "(Ljava/io/InputStream;)V",
                        false
                );

                if (functionName.equals("read_line")) {
                    mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/util/Scanner",
                            "nextLine",
                            "()Ljava/lang/String;",
                            false
                    );
                } else if (functionName.equals("read_integer")) {
                    mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/util/Scanner",
                            "nextInt",
                            "()I",
                            false
                    );
                }
            } else {
                throw new UnsupportedOperationException("Function calls not supported in this version");
            }
        }
    }

    private void generateLiteral(gemParser.LiteralContext ctx, MethodVisitor mv) {
        if (ctx.INTEGER_LITERAL() != null) {
            int value = Integer.parseInt(ctx.INTEGER_LITERAL().getText());
            switch (value) {
                case -1 -> mv.visitInsn(Opcodes.ICONST_M1);
                case 0 -> mv.visitInsn(Opcodes.ICONST_0);
                case 1 -> mv.visitInsn(Opcodes.ICONST_1);
                case 2 -> mv.visitInsn(Opcodes.ICONST_2);
                case 3 -> mv.visitInsn(Opcodes.ICONST_3);
                case 4 -> mv.visitInsn(Opcodes.ICONST_4);
                case 5 -> mv.visitInsn(Opcodes.ICONST_5);
                default -> {
                    if (value >= -128 && value <= 127) {
                        mv.visitIntInsn(Opcodes.BIPUSH, value);
                    } else if (value >= -32768 && value <= 32767) {
                        mv.visitIntInsn(Opcodes.SIPUSH, value);
                    } else {
                        mv.visitLdcInsn(value);
                    }
                }
            }
        } else if (ctx.FLOAT_LITERAL() != null) {
            float value = Float.parseFloat(ctx.FLOAT_LITERAL().getText());
            if (value == 0.0f) {
                mv.visitInsn(Opcodes.FCONST_0);
            } else if (value == 1.0f) {
                mv.visitInsn(Opcodes.FCONST_1);
            } else if (value == 2.0f) {
                mv.visitInsn(Opcodes.FCONST_2);
            } else {
                mv.visitLdcInsn(value);
            }
        } else if (ctx.STRING_LITERAL() != null) {
            String value = ctx.STRING_LITERAL().getText();
            value = value.substring(1, value.length() - 1);
            mv.visitLdcInsn(value);
        } else if (ctx.BOOLEAN_LITERAL() != null) {
            String value = ctx.BOOLEAN_LITERAL().getText();
            if (value.equals("yes")) {
                mv.visitInsn(Opcodes.ICONST_1);
            } else {
                mv.visitInsn(Opcodes.ICONST_0);
            }
        } else if (ctx.arrayLiteral() != null) {
            throw new UnsupportedOperationException("Arrays not supported in this version");
        }
    }

    private void loadVariable(String name, String type, MethodVisitor mv) {
        if (!localVars.containsKey(name)) {
            throw new RuntimeException("Variable not found: " + name);
        }

        int index = localVars.get(name);

        if (type == null) {
            type = definedVariables.get(name);
            if (type == null) {
                type = "integer";
            }
        }

        switch (type) {
            case "integer", "boolean" -> mv.visitVarInsn(Opcodes.ILOAD, index);
            case "number" -> mv.visitVarInsn(Opcodes.FLOAD, index);
            case "string" -> mv.visitVarInsn(Opcodes.ALOAD, index);
            default -> throw new UnsupportedOperationException("Loading not supported for type: " + type);
        }
    }

    private void storeVariable(String name, String type, MethodVisitor mv) {
        if (!localVars.containsKey(name)) {
            throw new RuntimeException("Variable not found: " + name);
        }

        int index = localVars.get(name);

        switch (type) {
            case "integer", "boolean" -> mv.visitVarInsn(Opcodes.ISTORE, index);
            case "number" -> mv.visitVarInsn(Opcodes.FSTORE, index);
            case "string" -> mv.visitVarInsn(Opcodes.ASTORE, index);
            default -> throw new UnsupportedOperationException("Storing not supported for type: " + type);
        }
    }

    private String getTypeString(gemParser.TypeContext ctx) {
        if (ctx.INTEGER_TYPE() != null) return "integer";
        if (ctx.NUMBER_TYPE() != null) return "number";
        if (ctx.STRING_TYPE() != null) return "string";
        if (ctx.BOOLEAN_TYPE() != null) return "boolean";
        if (ctx.CHAR_TYPE() != null) return "char";

        if (ctx.type() != null && ctx.LBRACK() != null) {
            throw new UnsupportedOperationException("Arrays not supported in this version");
        }

        if (ctx.ID() != null) {
            return ctx.ID().getText();
        }

        return null;
    }

    private String getExpressionType(Object ctx) {
        if (ctx instanceof gemParser.ExpressionContext) {
            return getLogicalExpressionType(((gemParser.ExpressionContext) ctx).logicalExpression());
        } else if (ctx instanceof gemParser.AdditiveExpressionContext) {
            return getAdditiveExpressionType((gemParser.AdditiveExpressionContext) ctx);
        }
        return "unknown";
    }

    private String getLogicalExpressionType(gemParser.LogicalExpressionContext ctx) {
        if (ctx.comparisonExpression().size() > 1 ||
                (ctx.getChildCount() > 1 &&
                        (ctx.getChild(1).getText().equals("and") ||
                                ctx.getChild(1).getText().equals("or")))) {
            return "boolean";
        }
        return getComparisonExpressionType(ctx.comparisonExpression(0));
    }

    private String getComparisonExpressionType(gemParser.ComparisonExpressionContext ctx) {
        if (ctx.getChildCount() > 1) {
            return "boolean";
        }
        return getAdditiveExpressionType(ctx.additiveExpression(0));
    }

    private String getAdditiveExpressionType(gemParser.AdditiveExpressionContext ctx) {
        for (gemParser.MultiplicativeExpressionContext mexpr : ctx.multiplicativeExpression()) {
            if ("string".equals(getMultiplicativeExpressionType(mexpr))) {
                return "string";
            }
        }
        return getMultiplicativeExpressionType(ctx.multiplicativeExpression(0));
    }

    private String getMultiplicativeExpressionType(gemParser.MultiplicativeExpressionContext ctx) {
        if (ctx.messageExpression().size() == 1) {
            return getMessageExpressionType(ctx.messageExpression(0));
        }

        String leftType = getMessageExpressionType(ctx.messageExpression(0));
        for (int i = 1; i < ctx.messageExpression().size(); i++) {
            String rightType = getMessageExpressionType(ctx.messageExpression(i));

            if (leftType.equals("string") || rightType.equals("string")) {
                return "string";
            }

            if (leftType.equals("number") || rightType.equals("number")) {
                return "number";
            }
        }

        return leftType;
    }

    private String getMessageExpressionType(gemParser.MessageExpressionContext ctx) {
        if (ctx.primaryExpression() != null) {
            return getPrimaryExpressionType(ctx.primaryExpression());
        }
        return "unknown";
    }

    private String getPrimaryExpressionType(gemParser.PrimaryExpressionContext ctx) {
        if (ctx.ID() != null && ctx.LPAREN() == null) {
            String varName = ctx.ID().getText();
            String type = semanticAnalyzer.getVariableType(varName);
            if (type == null) {
                type = definedVariables.get(varName);
            }
            return type;
        } else if (ctx.literal() != null) {
            return getLiteralType(ctx.literal());
        } else if (ctx.expression() != null) {
            return getExpressionType(ctx.expression());
        } else if (ctx.ID() != null && ctx.LPAREN() != null) {
            String funcName = ctx.ID().getText();
            if (funcName.equals("read_integer")) return "integer";
            if (funcName.equals("read_line")) return "string";
            return "unknown";
        }
        return "unknown";
    }

    private String getLiteralType(gemParser.LiteralContext ctx) {
        if (ctx.INTEGER_LITERAL() != null) return "integer";
        if (ctx.FLOAT_LITERAL() != null) return "number";
        if (ctx.STRING_LITERAL() != null) return "string";
        if (ctx.CHAR_LITERAL() != null) return "char";
        if (ctx.BOOLEAN_LITERAL() != null) return "boolean";
        return "unknown";
    }

    private void generateIntegerInputWithErrorHandling(MethodVisitor mv) {
        Label loopStart = new Label();
        Label loopEnd = new Label();
        Label tryStart = new Label();
        Label tryEnd = new Label();
        Label catchHandler = new Label();

        mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
        mv.visitInsn(Opcodes.DUP);
        mv.visitFieldInsn(
                Opcodes.GETSTATIC,
                "java/lang/System",
                "in",
                "Ljava/io/InputStream;"
        );
        mv.visitMethodInsn(
                Opcodes.INVOKESPECIAL,
                "java/util/Scanner",
                "<init>",
                "(Ljava/io/InputStream;)V",
                false
        );

        int scannerVarIndex = nextVarIndex++;
        mv.visitVarInsn(Opcodes.ASTORE, scannerVarIndex);

        mv.visitLabel(loopStart);

        mv.visitTryCatchBlock(tryStart, tryEnd, catchHandler, "java/util/InputMismatchException");

        mv.visitLabel(tryStart);

        mv.visitVarInsn(Opcodes.ALOAD, scannerVarIndex);

        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/util/Scanner",
                "nextInt",
                "()I",
                false
        );

        mv.visitJumpInsn(Opcodes.GOTO, loopEnd);
        mv.visitLabel(tryEnd);

        mv.visitLabel(catchHandler);

        int exceptionVarIndex = nextVarIndex++;
        mv.visitVarInsn(Opcodes.ASTORE, exceptionVarIndex);

        mv.visitFieldInsn(
                Opcodes.GETSTATIC,
                "java/lang/System",
                "out",
                "Ljava/io/PrintStream;"
        );
        mv.visitLdcInsn("Invalid input. Please enter a valid integer.");
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/io/PrintStream",
                "println",
                "(Ljava/lang/String;)V",
                false
        );

        mv.visitVarInsn(Opcodes.ALOAD, scannerVarIndex);
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/util/Scanner",
                "next",
                "()Ljava/lang/String;",
                false
        );
        mv.visitInsn(Opcodes.POP);

        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        mv.visitLabel(loopEnd);
    }
}