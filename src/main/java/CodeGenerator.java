import org.antlr.v4.runtime.tree.ParseTree;
import org.objectweb.asm.*;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class CodeGenerator {
    private GemSemanticAnalyzer semanticAnalyzer;
    private Map<String, Integer> localVars = new HashMap<>();
    private int nextVarIndex = 1; // 0 is reserved for 'this' in instance methods
    private Label currentBreakLabel = null;

    // Constructor
    public CodeGenerator() {
        // No parameters needed
    }

    public void generate(ParseTree tree, GemSemanticAnalyzer analyzer, String className, String outputFile) {
        this.semanticAnalyzer = analyzer;

        try {
            // Create class writer
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

            // Create the class
            cw.visit(
                    Opcodes.V20, // Java 20 class version
                    Opcodes.ACC_PUBLIC,
                    className,
                    null, // signature
                    "java/lang/Object", // superclass
                    null // interfaces
            );

            // Add default constructor
            MethodVisitor constructor = cw.visitMethod(
                    Opcodes.ACC_PUBLIC,
                    "<init>",
                    "()V",
                    null,
                    null
            );
            constructor.visitCode();
            constructor.visitVarInsn(Opcodes.ALOAD, 0);
            constructor.visitMethodInsn(
                    Opcodes.INVOKESPECIAL,
                    "java/lang/Object",
                    "<init>",
                    "()V",
                    false
            );
            constructor.visitInsn(Opcodes.RETURN);
            constructor.visitMaxs(1, 1);
            constructor.visitEnd();

            // Add main method
            MethodVisitor mv = cw.visitMethod(
                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
                    "main",
                    "([Ljava/lang/String;)V",
                    null,
                    null
            );
            mv.visitCode();

            // Register args parameter
            localVars.put("args", 0);

            // Process the AST - generate main method code
            generateProgram((gemParser.ProgramContext)tree, mv);

            // Exit main method
            mv.visitInsn(Opcodes.RETURN);
            mv.visitMaxs(0, 0); // Will be auto-computed
            mv.visitEnd();

            cw.visitEnd();

            // Write the class file
            try (FileOutputStream fos = new FileOutputStream(outputFile)) {
                fos.write(cw.toByteArray());
            }

            System.out.println("Successfully generated bytecode: " + outputFile);
        } catch (IOException e) {
            System.err.println("Error generating bytecode: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void generateProgram(gemParser.ProgramContext ctx, MethodVisitor mv) {
        // Skip declarations for now (will be supported in the next assignment)

        // Generate code for statements
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }
    }

    private void generateStatement(gemParser.StatementContext ctx, MethodVisitor mv) {
        if (ctx.variableDeclaration() != null) {
            generateVariableDeclaration(ctx.variableDeclaration(), mv);
        } else if (ctx.assignment() != null) {
            generateAssignment(ctx.assignment(), mv);
        } else if (ctx.ifStatement() != null) {
            generateIfStatement(ctx.ifStatement(), mv);
        } else if (ctx.forLoop() != null) {
            generateForLoop(ctx.forLoop(), mv);
        } else if (ctx.whileLoop() != null) {
            generateWhileLoop(ctx.whileLoop(), mv);
        } else if (ctx.loop() != null) {
            generateLoop(ctx.loop(), mv);
        } else if (ctx.printStatement() != null) {
            generatePrintStatement(ctx.printStatement(), mv);
        } else if (ctx.readStatement() != null) {
            generateReadStatement(ctx.readStatement(), mv);
        } else if (ctx.expression() != null) {
            // Evaluate expression and discard result
            generateExpression(ctx.expression(), mv);
            mv.visitInsn(Opcodes.POP); // Pop the value from the stack
        } else if (ctx.functionCall() != null) {
            // Special handling for console I/O functions
            String functionName = ctx.functionCall().ID(0).getText();
            if (functionName.equals("read_integer") || functionName.equals("read_line")) {
                // Create a read statement context or directly implement the read logic here

                // Create a Scanner
                mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
                mv.visitInsn(Opcodes.DUP);
                mv.visitFieldInsn(
                        Opcodes.GETSTATIC,
                        "java/lang/System",
                        "in",
                        "Ljava/io/InputStream;"
                );
                mv.visitMethodInsn(
                        Opcodes.INVOKESPECIAL,
                        "java/util/Scanner",
                        "<init>",
                        "(Ljava/io/InputStream;)V",
                        false
                );

                // Call appropriate method
                if (functionName.equals("read_line")) {
                    mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/util/Scanner",
                            "nextLine",
                            "()Ljava/lang/String;",
                            false
                    );
                } else if (functionName.equals("read_integer")) {
                    mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/util/Scanner",
                            "nextInt",
                            "()I",
                            false
                    );
                }
            } else {
                // Other function calls are not supported yet
                throw new UnsupportedOperationException("Function calls not supported in this version");
            }
        } else if (ctx.innerFunctionDeclaration() != null ||
                ctx.returnStatement() != null || ctx.breakStatement() != null) {
            throw new UnsupportedOperationException("Functions not supported in this version");
        } else {
            throw new UnsupportedOperationException("Unsupported statement type");
        }
    }

    private void generateVariableDeclaration(gemParser.VariableDeclarationContext ctx, MethodVisitor mv) {
        if (ctx.struct_type() != null || ctx.class_type() != null) {
            throw new UnsupportedOperationException("Composite types not supported in this version");
        }

        String varName = ctx.ID().getText();
        String typeName = getTypeString(ctx.type());

        // Register the variable
        int varIndex = nextVarIndex++;
        localVars.put(varName, varIndex);

        // Initialize with expression if provided
        if (ctx.expression() != null) {
            generateExpression(ctx.expression(), mv);
            storeVariable(varName, typeName, mv);
        } else {
            // Default initialization
            switch(typeName) {
                case "integer", "boolean" -> {
                    mv.visitInsn(Opcodes.ICONST_0);
                    mv.visitVarInsn(Opcodes.ISTORE, varIndex);
                }
                case "number" -> {
                    mv.visitInsn(Opcodes.FCONST_0);
                    mv.visitVarInsn(Opcodes.FSTORE, varIndex);
                }
                case "string" -> {
                    mv.visitInsn(Opcodes.ACONST_NULL);
                    mv.visitVarInsn(Opcodes.ASTORE, varIndex);
                }
                default -> throw new UnsupportedOperationException("Unsupported variable type: " + typeName);
            }
        }
    }

    private void generateAssignment(gemParser.AssignmentContext ctx, MethodVisitor mv) {
        if (ctx.ID().size() > 1 || ctx.LBRACK() != null) {
            throw new UnsupportedOperationException("Field and array assignments not supported in this version");
        }

        String varName = ctx.ID(0).getText();
        String typeName = semanticAnalyzer.getVariableType(varName);

        generateExpression(ctx.expression(0), mv);
        storeVariable(varName, typeName, mv);
    }

    private void generateIfStatement(gemParser.IfStatementContext ctx, MethodVisitor mv) {
        if (ctx.THEN() != null) {
            // Single-line if-then form
            Label endLabel = new Label();

            // Generate condition
            generateExpression(ctx.expression(0), mv);
            mv.visitJumpInsn(Opcodes.IFEQ, endLabel);

            // Generate then statement
            generateStatement(ctx.statement(0), mv);

            // Handle optional else
            if (ctx.ELSE() != null) {
                Label afterElseLabel = new Label();
                mv.visitJumpInsn(Opcodes.GOTO, afterElseLabel);
                mv.visitLabel(endLabel);
                generateStatement(ctx.statement(1), mv);
                mv.visitLabel(afterElseLabel);
            } else {
                mv.visitLabel(endLabel);
            }
        } else {
            // Multi-line if-then-end form
            Label endLabel = new Label();

            // Process each if/else-if condition with proper branching
            int numExpressions = ctx.expression().size();
            Label[] falseLabels = new Label[numExpressions];

            for (int i = 0; i < numExpressions; i++) {
                falseLabels[i] = new Label();

                // Generate condition
                generateExpression(ctx.expression(i), mv);
                mv.visitJumpInsn(Opcodes.IFEQ, falseLabels[i]);

                // Generate statements for this block
                int startStmt = calculateStartStatementIndex(ctx, i);
                int endStmt = calculateEndStatementIndex(ctx, i);

                for (int j = startStmt; j < endStmt; j++) {
                    generateStatement(ctx.statement(j), mv);
                }

                // Skip to end when this block is finished
                mv.visitJumpInsn(Opcodes.GOTO, endLabel);

                // Add false label for this condition
                mv.visitLabel(falseLabels[i]);
            }

            // Final else block (if exists)
            if (ctx.ELSE() != null) {
                int startStmt = calculateElseStatementIndex(ctx);
                for (int j = startStmt; j < ctx.statement().size(); j++) {
                    generateStatement(ctx.statement(j), mv);
                }
            }

            mv.visitLabel(endLabel);
        }
    }

    // Helper methods to calculate statement indices
    private int calculateStartStatementIndex(gemParser.IfStatementContext ctx, int conditionIndex) {
        if (conditionIndex == 0) return 0;
        return calculateEndStatementIndex(ctx, conditionIndex - 1);
    }

    private int calculateEndStatementIndex(gemParser.IfStatementContext ctx, int conditionIndex) {
        // Simple heuristic: divide statements evenly among conditions
        // This is a simplified approach - a real compiler would need more complex analysis
        int numConditions = ctx.expression().size();
        int statementsPerCondition = ctx.ELSE() != null ?
                (ctx.statement().size() / (numConditions + 1)) :
                (ctx.statement().size() / numConditions);

        return Math.min((conditionIndex + 1) * statementsPerCondition, ctx.statement().size());
    }

    private int calculateElseStatementIndex(gemParser.IfStatementContext ctx) {
        int numConditions = ctx.expression().size();
        int statementsPerCondition = ctx.statement().size() / (numConditions + 1);
        return numConditions * statementsPerCondition;
    }

    private void generateForLoop(gemParser.ForLoopContext ctx, MethodVisitor mv) {
        String loopVar = ctx.ID().getText();
        int varIndex = nextVarIndex++;
        localVars.put(loopVar, varIndex);

        // Loop control labels
        Label loopStart = new Label();
        Label loopEnd = new Label();

        // Initialize counter
        generateExpression(ctx.expression(0), mv);
        mv.visitVarInsn(Opcodes.ISTORE, varIndex);

        // Loop condition
        mv.visitLabel(loopStart);
        mv.visitVarInsn(Opcodes.ILOAD, varIndex);
        generateExpression(ctx.expression(1), mv);
        mv.visitJumpInsn(Opcodes.IF_ICMPGT, loopEnd);

        // Loop body
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        // Increment counter
        mv.visitIincInsn(varIndex, 1);
        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        // End of loop
        mv.visitLabel(loopEnd);
    }

    private void generateWhileLoop(gemParser.WhileLoopContext ctx, MethodVisitor mv) {
        // Loop control labels
        Label loopStart = new Label();
        Label loopEnd = new Label();

        // Loop condition
        mv.visitLabel(loopStart);
        generateExpression(ctx.expression(), mv);
        mv.visitJumpInsn(Opcodes.IFEQ, loopEnd);

        // Loop body
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        // Jump back to condition
        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        // End of loop
        mv.visitLabel(loopEnd);
    }

    private void generateLoop(gemParser.LoopContext ctx, MethodVisitor mv) {
        // Loop control labels
        Label loopStart = new Label();
        Label loopEnd = new Label(); // For future break support

        // Start of loop
        mv.visitLabel(loopStart);

        // Loop body
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        // Jump back to start
        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        // End of loop (for break statements)
        mv.visitLabel(loopEnd);
    }

    private void generatePrintStatement(gemParser.PrintStatementContext ctx, MethodVisitor mv) {
        // Get System.out
        mv.visitFieldInsn(
                Opcodes.GETSTATIC,
                "java/lang/System",
                "out",
                "Ljava/io/PrintStream;"
        );

        // Generate the expression
        String exprType = getExpressionType(ctx.expression());

        // Check if it's a string concatenation operation
        if (isConcatenation(ctx.expression())) {
            generateStringConcatenation(ctx.expression(), mv);
        } else {
            // Generate a normal expression
            generateExpression(ctx.expression(), mv);

            // Convert primitive types to String if needed
            if (!exprType.equals("string")) {
                switch(exprType) {
                    case "integer" -> mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            "java/lang/String",
                            "valueOf",
                            "(I)Ljava/lang/String;",
                            false
                    );
                    case "number" -> mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            "java/lang/String",
                            "valueOf",
                            "(F)Ljava/lang/String;",
                            false
                    );
                    case "boolean" -> mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            "java/lang/String",
                            "valueOf",
                            "(Z)Ljava/lang/String;",
                            false
                    );
                    default -> throw new UnsupportedOperationException("Cannot print type: " + exprType);
                }
            }
        }

        // Call println
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/io/PrintStream",
                "println",
                "(Ljava/lang/String;)V",
                false
        );
    }

    // Helper method to check if an expression is a string concatenation
    private boolean isConcatenation(gemParser.ExpressionContext ctx) {
        // Get the first comparison expression
        gemParser.ComparisonExpressionContext compCtx = ctx.logicalExpression().comparisonExpression(0);
        // Get the first additive expression
        gemParser.AdditiveExpressionContext addCtx = compCtx.additiveExpression(0);
        return addCtx.multiplicativeExpression().size() > 1 && addCtx.PLUS().size() > 0;
    }

    // Method to generate string concatenation
    private void generateStringConcatenation(gemParser.ExpressionContext ctx, MethodVisitor mv) {
        // Create a StringBuilder
        mv.visitTypeInsn(Opcodes.NEW, "java/lang/StringBuilder");
        mv.visitInsn(Opcodes.DUP);
        mv.visitMethodInsn(
                Opcodes.INVOKESPECIAL,
                "java/lang/StringBuilder",
                "<init>",
                "()V",
                false
        );

        // Get the additive expression containing the concatenations
        gemParser.ComparisonExpressionContext compCtx = ctx.logicalExpression().comparisonExpression(0);
        gemParser.AdditiveExpressionContext addCtx = compCtx.additiveExpression(0);

        // Generate code for the first operand
        String firstType = getMultiplicativeExpressionType(addCtx.multiplicativeExpression(0));
        generateMultiplicativeExpression(addCtx.multiplicativeExpression(0), mv);

        // Convert to string if needed and append
        appendToStringBuilder(mv, firstType);

        // Process the remaining operands
        for (int i = 1; i < addCtx.multiplicativeExpression().size(); i++) {
            String opType = getMultiplicativeExpressionType(addCtx.multiplicativeExpression(i));
            generateMultiplicativeExpression(addCtx.multiplicativeExpression(i), mv);

            // Convert to string if needed and append
            appendToStringBuilder(mv, opType);
        }

        // Convert StringBuilder to String
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/StringBuilder",
                "toString",
                "()Ljava/lang/String;",
                false
        );
    }

    // Helper method to append a value to StringBuilder
    private void appendToStringBuilder(MethodVisitor mv, String type) {
        // Append method signature depends on the type
        String descriptor;
        switch (type) {
            case "integer" -> descriptor = "(I)Ljava/lang/StringBuilder;";
            case "number" -> descriptor = "(F)Ljava/lang/StringBuilder;";
            case "boolean" -> descriptor = "(Z)Ljava/lang/StringBuilder;";
            case "string" -> descriptor = "(Ljava/lang/String;)Ljava/lang/StringBuilder;";
            default -> descriptor = "(Ljava/lang/Object;)Ljava/lang/StringBuilder;";
        }

        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/StringBuilder",
                "append",
                descriptor,
                false
        );
    }

    private void generateReadStatement(gemParser.ReadStatementContext ctx, MethodVisitor mv) {
        String funcName = ctx.ID().getText();

        // Create Scanner
        mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
        mv.visitInsn(Opcodes.DUP);
        mv.visitFieldInsn(
                Opcodes.GETSTATIC,
                "java/lang/System",
                "in",
                "Ljava/io/InputStream;"
        );
        mv.visitMethodInsn(
                Opcodes.INVOKESPECIAL,
                "java/util/Scanner",
                "<init>",
                "(Ljava/io/InputStream;)V",
                false
        );

        // Call appropriate method
        if (funcName.equals("read_line")) {
            mv.visitMethodInsn(
                    Opcodes.INVOKEVIRTUAL,
                    "java/util/Scanner",
                    "nextLine",
                    "()Ljava/lang/String;",
                    false
            );
        } else if (funcName.equals("read_integer")) {
            mv.visitMethodInsn(
                    Opcodes.INVOKEVIRTUAL,
                    "java/util/Scanner",
                    "nextInt",
                    "()I",
                    false
            );
        } else {
            throw new UnsupportedOperationException("Unsupported read function: " + funcName);
        }

        // Result is on stack, caller needs to store it
    }

    private void generateExpression(gemParser.ExpressionContext ctx, MethodVisitor mv) {
        generateLogicalExpression(ctx.logicalExpression(), mv);
    }

    private void generateLogicalExpression(gemParser.LogicalExpressionContext ctx, MethodVisitor mv) {
        if (ctx.comparisonExpression().size() == 1) {
            generateComparisonExpression(ctx.comparisonExpression(0), mv);
            return;
        }

        // First operand
        generateComparisonExpression(ctx.comparisonExpression(0), mv);

        for (int i = 0; i < ctx.getChildCount() / 2; i++) {
            String operator = ctx.getChild(i * 2 + 1).getText();

            if (operator.equals("and")) {
                // Short-circuit AND
                Label falseLabel = new Label();
                Label endLabel = new Label();

                // Check if first operand is false
                mv.visitJumpInsn(Opcodes.IFEQ, falseLabel);

                // Evaluate second operand
                generateComparisonExpression(ctx.comparisonExpression(i + 1), mv);
                mv.visitJumpInsn(Opcodes.GOTO, endLabel);

                // First operand was false, result is false
                mv.visitLabel(falseLabel);
                mv.visitInsn(Opcodes.ICONST_0);

                mv.visitLabel(endLabel);
            } else if (operator.equals("or")) {
                // Short-circuit OR
                Label trueLabel = new Label();
                Label endLabel = new Label();

                // Check if first operand is true
                mv.visitJumpInsn(Opcodes.IFNE, trueLabel);

                // Evaluate second operand
                generateComparisonExpression(ctx.comparisonExpression(i + 1), mv);
                mv.visitJumpInsn(Opcodes.GOTO, endLabel);

                // First operand was true, result is true
                mv.visitLabel(trueLabel);
                mv.visitInsn(Opcodes.ICONST_1);

                mv.visitLabel(endLabel);
            }
        }
    }

    private void generateComparisonExpression(gemParser.ComparisonExpressionContext ctx, MethodVisitor mv) {
        if (ctx.additiveExpression().size() == 1) {
            generateAdditiveExpression(ctx.additiveExpression(0), mv);
            return;
        }

        // Generate operands
        generateAdditiveExpression(ctx.additiveExpression(0), mv);
        generateAdditiveExpression(ctx.additiveExpression(1), mv);

        // Compare based on operator
        String op = ctx.getChild(1).getText();
        Label trueLabel = new Label();
        Label endLabel = new Label();

        switch (op) {
            case "<" -> mv.visitJumpInsn(Opcodes.IF_ICMPLT, trueLabel);
            case ">" -> mv.visitJumpInsn(Opcodes.IF_ICMPGT, trueLabel);
            case "<=" -> mv.visitJumpInsn(Opcodes.IF_ICMPLE, trueLabel);
            case ">=" -> mv.visitJumpInsn(Opcodes.IF_ICMPGE, trueLabel);
            case "==" -> mv.visitJumpInsn(Opcodes.IF_ICMPEQ, trueLabel);
            case "!=" -> mv.visitJumpInsn(Opcodes.IF_ICMPNE, trueLabel);
            default -> throw new UnsupportedOperationException("Unsupported comparison operator: " + op);
        }

        // False path
        mv.visitInsn(Opcodes.ICONST_0);
        mv.visitJumpInsn(Opcodes.GOTO, endLabel);

        // True path
        mv.visitLabel(trueLabel);
        mv.visitInsn(Opcodes.ICONST_1);

        mv.visitLabel(endLabel);
    }

    private void generateAdditiveExpression(gemParser.AdditiveExpressionContext ctx, MethodVisitor mv) {
        if (ctx.multiplicativeExpression().size() == 1) {
            generateMultiplicativeExpression(ctx.multiplicativeExpression(0), mv);
            return;
        }

        // First operand
        generateMultiplicativeExpression(ctx.multiplicativeExpression(0), mv);

        // Process operations left to right
        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            generateMultiplicativeExpression(ctx.multiplicativeExpression(i), mv);

            String op = ctx.getChild(i * 2 - 1).getText();
            if (op.equals("+")) {
                mv.visitInsn(Opcodes.IADD);
            } else if (op.equals("-")) {
                mv.visitInsn(Opcodes.ISUB);
            }
        }
    }

    private void generateMultiplicativeExpression(gemParser.MultiplicativeExpressionContext ctx, MethodVisitor mv) {
        generateMessageExpression(ctx.messageExpression(0), mv);

        for (int i = 1; i < ctx.messageExpression().size(); i++) {
            generateMessageExpression(ctx.messageExpression(i), mv);

            String op = ctx.getChild(i * 2 - 1).getText();
            switch (op) {
                case "*" -> mv.visitInsn(Opcodes.IMUL);
                case "/" -> mv.visitInsn(Opcodes.IDIV);
                case "%" -> mv.visitInsn(Opcodes.IREM);
                default -> throw new UnsupportedOperationException("Unsupported multiplicative operator: " + op);
            }
        }
    }

    private void generateMessageExpression(gemParser.MessageExpressionContext ctx, MethodVisitor mv) {
        if (ctx.ARROW() != null || (ctx.DOT() != null && ctx.LPAREN() != null) || ctx.LBRACK() != null) {
            throw new UnsupportedOperationException("Message passing, method calls, and arrays not supported in this version");
        }

        if (ctx.DOT() != null) {
            throw new UnsupportedOperationException("Field access not supported in this version");
        }

        generatePrimaryExpression(ctx.primaryExpression(), mv);
    }

    private void generatePrimaryExpression(gemParser.PrimaryExpressionContext ctx, MethodVisitor mv) {
        if (ctx.ID() != null && ctx.LPAREN() == null) {
            // Variable reference
            String varName = ctx.ID().getText();
            String varType = semanticAnalyzer.getVariableType(varName);
            loadVariable(varName, varType, mv);
        } else if (ctx.literal() != null) {
            // Literal value
            generateLiteral(ctx.literal(), mv);
        } else if (ctx.expression() != null) {
            // Parenthesized expression
            generateExpression(ctx.expression(), mv);
        } else if (ctx.ID() != null && ctx.LPAREN() != null) {
            // Function call
            String functionName = ctx.ID().getText();
            if (functionName.equals("read_integer") || functionName.equals("read_line")) {
                // Handle built-in I/O functions
                // Create a Scanner
                mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
                mv.visitInsn(Opcodes.DUP);
                mv.visitFieldInsn(
                        Opcodes.GETSTATIC,
                        "java/lang/System",
                        "in",
                        "Ljava/io/InputStream;"
                );
                mv.visitMethodInsn(
                        Opcodes.INVOKESPECIAL,
                        "java/util/Scanner",
                        "<init>",
                        "(Ljava/io/InputStream;)V",
                        false
                );

                // Call appropriate method
                if (functionName.equals("read_line")) {
                    mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/util/Scanner",
                            "nextLine",
                            "()Ljava/lang/String;",
                            false
                    );
                } else if (functionName.equals("read_integer")) {
                    mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/util/Scanner",
                            "nextInt",
                            "()I",
                            false
                    );
                }
            } else {
                throw new UnsupportedOperationException("Function calls not supported in this version");
            }
        }
    }

    private void generateLiteral(gemParser.LiteralContext ctx, MethodVisitor mv) {
        if (ctx.INTEGER_LITERAL() != null) {
            int value = Integer.parseInt(ctx.INTEGER_LITERAL().getText());
            switch (value) {
                case -1 -> mv.visitInsn(Opcodes.ICONST_M1);
                case 0 -> mv.visitInsn(Opcodes.ICONST_0);
                case 1 -> mv.visitInsn(Opcodes.ICONST_1);
                case 2 -> mv.visitInsn(Opcodes.ICONST_2);
                case 3 -> mv.visitInsn(Opcodes.ICONST_3);
                case 4 -> mv.visitInsn(Opcodes.ICONST_4);
                case 5 -> mv.visitInsn(Opcodes.ICONST_5);
                default -> {
                    if (value >= -128 && value <= 127) {
                        mv.visitIntInsn(Opcodes.BIPUSH, value);
                    } else if (value >= -32768 && value <= 32767) {
                        mv.visitIntInsn(Opcodes.SIPUSH, value);
                    } else {
                        mv.visitLdcInsn(value);
                    }
                }
            }
        } else if (ctx.FLOAT_LITERAL() != null) {
            float value = Float.parseFloat(ctx.FLOAT_LITERAL().getText());
            if (value == 0.0f) {
                mv.visitInsn(Opcodes.FCONST_0);
            } else if (value == 1.0f) {
                mv.visitInsn(Opcodes.FCONST_1);
            } else if (value == 2.0f) {
                mv.visitInsn(Opcodes.FCONST_2);
            } else {
                mv.visitLdcInsn(value);
            }
        } else if (ctx.STRING_LITERAL() != null) {
            String value = ctx.STRING_LITERAL().getText();
            // Remove quotes
            value = value.substring(1, value.length() - 1);
            mv.visitLdcInsn(value);
        } else if (ctx.BOOLEAN_LITERAL() != null) {
            String value = ctx.BOOLEAN_LITERAL().getText();
            if (value.equals("yes")) {
                mv.visitInsn(Opcodes.ICONST_1);
            } else {
                mv.visitInsn(Opcodes.ICONST_0);
            }
        } else if (ctx.arrayLiteral() != null) {
            throw new UnsupportedOperationException("Arrays not supported in this version");
        }
    }

    private void loadVariable(String name, String type, MethodVisitor mv) {
        if (!localVars.containsKey(name)) {
            throw new RuntimeException("Variable not found: " + name);
        }

        int index = localVars.get(name);

        switch (type) {
            case "integer", "boolean" -> mv.visitVarInsn(Opcodes.ILOAD, index);
            case "number" -> mv.visitVarInsn(Opcodes.FLOAD, index);
            case "string" -> mv.visitVarInsn(Opcodes.ALOAD, index);
            default -> throw new UnsupportedOperationException("Loading not supported for type: " + type);
        }
    }

    private void storeVariable(String name, String type, MethodVisitor mv) {
        if (!localVars.containsKey(name)) {
            throw new RuntimeException("Variable not found: " + name);
        }

        int index = localVars.get(name);

        switch (type) {
            case "integer", "boolean" -> mv.visitVarInsn(Opcodes.ISTORE, index);
            case "number" -> mv.visitVarInsn(Opcodes.FSTORE, index);
            case "string" -> mv.visitVarInsn(Opcodes.ASTORE, index);
            default -> throw new UnsupportedOperationException("Storing not supported for type: " + type);
        }
    }

    private String getTypeString(gemParser.TypeContext ctx) {
        if (ctx.INTEGER_TYPE() != null) return "integer";
        if (ctx.NUMBER_TYPE() != null) return "number";
        if (ctx.STRING_TYPE() != null) return "string";
        if (ctx.BOOLEAN_TYPE() != null) return "boolean";
        if (ctx.CHAR_TYPE() != null) return "char";

        if (ctx.type() != null && ctx.LBRACK() != null) {
            throw new UnsupportedOperationException("Arrays not supported in this version");
        }

        if (ctx.ID() != null) {
            return ctx.ID().getText();
        }

        return null;
    }

    // Type analysis methods
    private String getExpressionType(gemParser.ExpressionContext ctx) {
        return getLogicalExpressionType(ctx.logicalExpression());
    }

    private String getLogicalExpressionType(gemParser.LogicalExpressionContext ctx) {
        if (ctx.comparisonExpression().size() > 1 ||
                (ctx.getChildCount() > 1 &&
                        (ctx.getChild(1).getText().equals("and") ||
                                ctx.getChild(1).getText().equals("or")))) {
            return "boolean";
        }
        return getComparisonExpressionType(ctx.comparisonExpression(0));
    }

    private String getComparisonExpressionType(gemParser.ComparisonExpressionContext ctx) {
        if (ctx.getChildCount() > 1) {
            return "boolean";
        }
        return getAdditiveExpressionType(ctx.additiveExpression(0));
    }

    private String getAdditiveExpressionType(gemParser.AdditiveExpressionContext ctx) {
        if (ctx.multiplicativeExpression().size() > 1) {
            // Check if any operand is a string
            for (gemParser.MultiplicativeExpressionContext mexpr : ctx.multiplicativeExpression()) {
                if (getMultiplicativeExpressionType(mexpr).equals("string")) {
                    return "string";
                }
            }
            return getMultiplicativeExpressionType(ctx.multiplicativeExpression(0));
        }
        return getMultiplicativeExpressionType(ctx.multiplicativeExpression(0));
    }

    private String getMultiplicativeExpressionType(gemParser.MultiplicativeExpressionContext ctx) {
        // If there's only one message expression, return its type
        if (ctx.messageExpression().size() == 1) {
            return getMessageExpressionType(ctx.messageExpression(0));
        }

        // Otherwise, determine the result type based on the operands
        String leftType = getMessageExpressionType(ctx.messageExpression(0));
        for (int i = 1; i < ctx.messageExpression().size(); i++) {
            String rightType = getMessageExpressionType(ctx.messageExpression(i));

            // If either type is "string", the result is a string
            if (leftType.equals("string") || rightType.equals("string")) {
                return "string";
            }

            // If either type is "number", the result is a number
            if (leftType.equals("number") || rightType.equals("number")) {
                return "number";
            }
        }

        return leftType;
    }

    private String getMessageExpressionType(gemParser.MessageExpressionContext ctx) {
        if (ctx.primaryExpression() != null) {
            return getPrimaryExpressionType(ctx.primaryExpression());
        }
        return "unknown";
    }

    private String getPrimaryExpressionType(gemParser.PrimaryExpressionContext ctx) {
        if (ctx.ID() != null && ctx.LPAREN() == null) {
            // Variable reference
            String varName = ctx.ID().getText();
            return semanticAnalyzer.getVariableType(varName);
        } else if (ctx.literal() != null) {
            // Literal value
            return getLiteralType(ctx.literal());
        } else if (ctx.expression() != null) {
            // Parenthesized expression
            return getExpressionType(ctx.expression());
        } else if (ctx.ID() != null && ctx.LPAREN() != null) {
            // Function call - simplified for now
            String funcName = ctx.ID().getText();
            if (funcName.equals("read_integer")) return "integer";
            if (funcName.equals("read_line")) return "string";
            // For other functions, we'd need to look up their return types
            return "unknown";
        }
        return "unknown";
    }

    private String getLiteralType(gemParser.LiteralContext ctx) {
        if (ctx.INTEGER_LITERAL() != null) return "integer";
        if (ctx.FLOAT_LITERAL() != null) return "number";
        if (ctx.STRING_LITERAL() != null) return "string";
        if (ctx.CHAR_LITERAL() != null) return "char";
        if (ctx.BOOLEAN_LITERAL() != null) return "boolean";
        return "unknown";
    }
}