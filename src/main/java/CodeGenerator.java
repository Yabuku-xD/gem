import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode; // Added for TerminalNode
import org.objectweb.asm.*;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.*;

public class CodeGenerator {
    private GemSemanticAnalyzer semanticAnalyzer;
    private Map<String, Integer> localVars = new HashMap<>();
    private Map<String, String> definedVariables = new HashMap<>();
    private int nextVarIndex = 1; // Start at 1 for local vars if main's args is at 0
    private Label currentBreakLabel = null;
    private ClassWriter mainClassWriter;
    private String currentClassName;

    // For struct/class definitions
    private Map<String, ClassWriter> typeWriters = new HashMap<>();
    private Map<String, Map<String, String>> typeFields = new HashMap<>();
    private Map<String, Map<String, FunctionInfo>> typeMethods = new HashMap<>();

    // For function definitions
    private Map<String, FunctionInfo> functions = new HashMap<>();

    private static class FunctionInfo {
        String name;
        String descriptor;
        String returnType;
        List<String> paramTypes;
        List<String> paramNames;
        List<Boolean> paramRefs;
        ParseTree body;

        FunctionInfo(String name, String returnType) {
            this.name = name;
            this.returnType = returnType;
            this.paramTypes = new ArrayList<>();
            this.paramNames = new ArrayList<>();
            this.paramRefs = new ArrayList<>();
        }
    }

    public CodeGenerator() {
        this.definedVariables = new HashMap<>();
    }

    public void generate(ParseTree tree, GemSemanticAnalyzer analyzer, String className, String outputFile) {
        this.semanticAnalyzer = analyzer;
        this.currentClassName = className;

        for (Map.Entry<String, String> entry : analyzer.getAllVariableTypes().entrySet()) {
            definedVariables.put(entry.getKey(), entry.getValue());
        }

        try {
            mainClassWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

            mainClassWriter.visit(
                    Opcodes.V17, // Targeting Java 17
                    Opcodes.ACC_PUBLIC,
                    className,
                    null,
                    "java/lang/Object",
                    null
            );

            collectDeclarations((gemParser.ProgramContext)tree);
            generateTypeClasses();
            generateFunctions();

            MethodVisitor constructor = mainClassWriter.visitMethod(
                    Opcodes.ACC_PUBLIC,
                    "<init>",
                    "()V",
                    null,
                    null
            );
            constructor.visitCode();
            constructor.visitVarInsn(Opcodes.ALOAD, 0);
            constructor.visitMethodInsn(
                    Opcodes.INVOKESPECIAL,
                    "java/lang/Object",
                    "<init>",
                    "()V",
                    false
            );
            constructor.visitInsn(Opcodes.RETURN);
            constructor.visitMaxs(1, 1);
            constructor.visitEnd();

            MethodVisitor mv = mainClassWriter.visitMethod(
                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
                    "main",
                    "([Ljava/lang/String;)V",
                    null,
                    null
            );
            mv.visitCode();
            localVars.clear();
            nextVarIndex = 1; // args is at 0, so first local starts at 1
            localVars.put("args", 0); // Main method args

            generateProgram((gemParser.ProgramContext)tree, mv);

            mv.visitInsn(Opcodes.RETURN);
            mv.visitMaxs(0, 0);
            mv.visitEnd();

            mainClassWriter.visitEnd();

            try (FileOutputStream fos = new FileOutputStream(outputFile)) {
                fos.write(mainClassWriter.toByteArray());
            }

            for (Map.Entry<String, ClassWriter> entry : typeWriters.entrySet()) {
                String typeName = entry.getKey();
                ClassWriter cw = entry.getValue();
                cw.visitEnd();
                try (FileOutputStream fos = new FileOutputStream(typeName + ".class")) {
                    fos.write(cw.toByteArray());
                }
            }
            System.out.println("Successfully generated bytecode: " + outputFile);
        } catch (IOException e) {
            System.err.println("Error generating bytecode: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void collectDeclarations(gemParser.ProgramContext ctx) {
        for (gemParser.DeclarationContext decl : ctx.declaration()) {
            if (decl.structDeclaration() != null) {
                collectStructDeclaration(decl.structDeclaration());
            } else if (decl.classDeclaration() != null) {
                collectClassDeclaration(decl.classDeclaration());
            } else if (decl.functionDeclaration() != null) {
                collectFunctionDeclaration(decl.functionDeclaration());
            } else if (decl.messageDeclaration() != null) {
                collectMessageDeclaration(decl.messageDeclaration());
            }
        }
    }

    private void collectStructDeclaration(gemParser.StructDeclarationContext ctx) {
        String structName = ctx.ID(0).getText();
        Map<String, String> fields = new LinkedHashMap<>();
        
        // Handle inheritance - copy fields from parent struct
        if (ctx.ID().size() > 1) {
            String parentName = ctx.ID(1).getText();
            Map<String, String> parentFields = typeFields.get(parentName);
            if (parentFields != null) {
                fields.putAll(parentFields); // Inherit parent fields
            }
        }
        
        // Add own fields
        for (gemParser.FieldContext field : ctx.field()) {
            fields.put(field.ID().getText(), getTypeString(field.type()));
        }
        typeFields.put(structName, fields);
        
        // Check if this struct is a message type
        boolean isMessageType = ctx.IS() != null && ctx.IS_MESSAGE() != null;
        
        // Generate bytecode for all structs (including message types)
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        cw.visit(Opcodes.V17, Opcodes.ACC_PUBLIC, structName, null, "java/lang/Object", null);
        
        // Add fields
        for (Map.Entry<String, String> field : fields.entrySet()) {
            cw.visitField(Opcodes.ACC_PUBLIC, field.getKey(), getTypeDescriptor(field.getValue()), null, null).visitEnd();
        }
        
        // Add constructor
        MethodVisitor constructor = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null);
        constructor.visitCode();
        constructor.visitVarInsn(Opcodes.ALOAD, 0);
        constructor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
        
        // Initialize fields with default values
        for (Map.Entry<String, String> field : fields.entrySet()) {
            constructor.visitVarInsn(Opcodes.ALOAD, 0);
            generateDefaultValue(field.getValue(), constructor);
            constructor.visitFieldInsn(Opcodes.PUTFIELD, structName, field.getKey(), getTypeDescriptor(field.getValue()));
        }
        
        constructor.visitInsn(Opcodes.RETURN);
        constructor.visitMaxs(2, 1); // Ensure enough stack space
        constructor.visitEnd();
        
        if (isMessageType) {
            System.out.println("Registered message type: " + structName);
            
            // For message types, we add a toString method to help with debugging
            MethodVisitor toStringMethod = cw.visitMethod(Opcodes.ACC_PUBLIC, "toString", "()Ljava/lang/String;", null, null);
            toStringMethod.visitCode();
            
            // Create a StringBuilder
            toStringMethod.visitTypeInsn(Opcodes.NEW, "java/lang/StringBuilder");
            toStringMethod.visitInsn(Opcodes.DUP);
            toStringMethod.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
            
            // Append the class name
            toStringMethod.visitLdcInsn(structName + "{");
            toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            
            // Append each field
            boolean first = true;
            for (Map.Entry<String, String> field : fields.entrySet()) {
                if (!first) {
                    toStringMethod.visitLdcInsn(", ");
                    toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
                }
                first = false;
                
                // Append field name
                toStringMethod.visitLdcInsn(field.getKey() + "=");
                toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
                
                // Append field value
                toStringMethod.visitVarInsn(Opcodes.ALOAD, 0);
                toStringMethod.visitFieldInsn(Opcodes.GETFIELD, structName, field.getKey(), getTypeDescriptor(field.getValue()));
                
                // Convert field to string based on its type
                String appendDescriptor = getAppendDescriptor(field.getValue());
                toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", appendDescriptor, false);
            }
            
            // Append closing brace
            toStringMethod.visitLdcInsn("}");
            toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            
            // Convert to string and return
            toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
            toStringMethod.visitInsn(Opcodes.ARETURN);
            toStringMethod.visitMaxs(3, 1);
            toStringMethod.visitEnd();
        }
        
        // Store the class writer for later use
        typeWriters.put(structName, cw);
    }
    
    private String getAppendDescriptor(String type) {
        switch (type) {
            case "integer": return "(I)Ljava/lang/StringBuilder;";
            case "number": return "(F)Ljava/lang/StringBuilder;";
            case "boolean": return "(Z)Ljava/lang/StringBuilder;";
            case "char": return "(C)Ljava/lang/StringBuilder;";
            default: return "(Ljava/lang/Object;)Ljava/lang/StringBuilder;";
        }
    }

    private void collectMessageDeclaration(gemParser.MessageDeclarationContext ctx) {
        String messageName = ctx.ID().getText();
        Map<String, String> fields = new LinkedHashMap<>();
        for (gemParser.FieldContext field : ctx.field()) {
            fields.put(field.ID().getText(), getTypeString(field.type()));
        }
        typeFields.put(messageName, fields);
        
        // Generate bytecode for message types (same as structs but always marked as message)
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        cw.visit(Opcodes.V17, Opcodes.ACC_PUBLIC, messageName, null, "java/lang/Object", null);
        
        // Add fields
        for (Map.Entry<String, String> field : fields.entrySet()) {
            cw.visitField(Opcodes.ACC_PUBLIC, field.getKey(), getTypeDescriptor(field.getValue()), null, null).visitEnd();
        }
        
        // Add constructor
        MethodVisitor constructor = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null);
        constructor.visitCode();
        constructor.visitVarInsn(Opcodes.ALOAD, 0);
        constructor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
        
        // Initialize fields with default values
        for (Map.Entry<String, String> field : fields.entrySet()) {
            constructor.visitVarInsn(Opcodes.ALOAD, 0);
            generateDefaultValue(field.getValue(), constructor);
            constructor.visitFieldInsn(Opcodes.PUTFIELD, messageName, field.getKey(), getTypeDescriptor(field.getValue()));
        }
        
        constructor.visitInsn(Opcodes.RETURN);
        constructor.visitMaxs(2, 1); // Ensure enough stack space
        constructor.visitEnd();
        
        System.out.println("Registered message type: " + messageName);
        
        // For message types, we add a toString method to help with debugging
        MethodVisitor toStringMethod = cw.visitMethod(Opcodes.ACC_PUBLIC, "toString", "()Ljava/lang/String;", null, null);
        toStringMethod.visitCode();
        
        // Create a StringBuilder
        toStringMethod.visitTypeInsn(Opcodes.NEW, "java/lang/StringBuilder");
        toStringMethod.visitInsn(Opcodes.DUP);
        toStringMethod.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
        
        // Append the class name
        toStringMethod.visitLdcInsn(messageName + "{");
        toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
        
        // Append each field
        boolean first = true;
        for (Map.Entry<String, String> field : fields.entrySet()) {
            if (!first) {
                toStringMethod.visitLdcInsn(", ");
                toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            }
            first = false;
            
            // Append field name
            toStringMethod.visitLdcInsn(field.getKey() + "=");
            toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            
            // Append field value
            toStringMethod.visitVarInsn(Opcodes.ALOAD, 0);
            toStringMethod.visitFieldInsn(Opcodes.GETFIELD, messageName, field.getKey(), getTypeDescriptor(field.getValue()));
            
            // Convert field to string based on its type
            String appendDescriptor = getAppendDescriptor(field.getValue());
            toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", appendDescriptor, false);
        }
        
        // Append closing brace
        toStringMethod.visitLdcInsn("}");
        toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
        
        // Convert to string and return
        toStringMethod.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
        toStringMethod.visitInsn(Opcodes.ARETURN);
        toStringMethod.visitMaxs(3, 1);
        toStringMethod.visitEnd();
        
        // Store the class writer for later use
        typeWriters.put(messageName, cw);
    }

    private void collectClassDeclaration(gemParser.ClassDeclarationContext ctx) {
        String className = ctx.ID(0).getText();
        Map<String, String> fields = new LinkedHashMap<>();
        Map<String, FunctionInfo> methods = new HashMap<>();
        for (gemParser.FieldContext field : ctx.field()) {
            fields.put(field.ID().getText(), getTypeString(field.type()));
        }
        for (gemParser.FunctionDeclarationContext funcCtx : ctx.functionDeclaration()) {
            FunctionInfo info = collectFunctionInfo(funcCtx);
            methods.put(info.name, info);
        }
        typeFields.put(className, fields);
        typeMethods.put(className, methods);
    }

    private void collectFunctionDeclaration(gemParser.FunctionDeclarationContext ctx) {
        FunctionInfo info = collectFunctionInfo(ctx);
        functions.put(info.name, info);
    }

    private FunctionInfo collectFunctionInfo(gemParser.FunctionDeclarationContext ctx) {
        String funcName = ctx.ID().getText();
        String returnType = ctx.type() != null ? getTypeString(ctx.type()) : "void";
        FunctionInfo info = new FunctionInfo(funcName, returnType);
        info.body = ctx;

        if (ctx.parameterList() != null) {
            for (gemParser.ParameterContext param : ctx.parameterList().parameter()) {
                info.paramTypes.add(getTypeString(param.type()));
                info.paramNames.add(param.ID().getText());
                info.paramRefs.add(param.REF() != null);
            }
        }
        StringBuilder desc = new StringBuilder("(");
        for (int i = 0; i < info.paramTypes.size(); i++) {
            desc.append(info.paramRefs.get(i) ? "[" : "").append(getTypeDescriptor(info.paramTypes.get(i)));
        }
        desc.append(")").append(getTypeDescriptor(returnType));
        info.descriptor = desc.toString();
        return info;
    }

    private void generateTypeClasses() {
        // Process all types that have fields defined (structs, classes, message types)
        for (Map.Entry<String, Map<String, String>> entry : typeFields.entrySet()) {
            String typeName = entry.getKey();
            Map<String, String> fields = entry.getValue();
            
            // Check if we already have a ClassWriter for this type (created during collection phase)
            ClassWriter cw = typeWriters.get(typeName);
            
            // If not, create a new one (this shouldn't happen with our current implementation
            // but is here for robustness)
            if (cw == null) {
                cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
                cw.visit(Opcodes.V17, Opcodes.ACC_PUBLIC, typeName, null, "java/lang/Object", null);

                // Add fields
                for (Map.Entry<String, String> field : fields.entrySet()) {
                    cw.visitField(Opcodes.ACC_PUBLIC, field.getKey(), getTypeDescriptor(field.getValue()), null, null).visitEnd();
                }

                // Add constructor
                MethodVisitor constructor = cw.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "()V", null, null);
                constructor.visitCode();
                constructor.visitVarInsn(Opcodes.ALOAD, 0);
                constructor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
                
                // Initialize fields with default values
                for (Map.Entry<String, String> field : fields.entrySet()) {
                    constructor.visitVarInsn(Opcodes.ALOAD, 0);
                    generateDefaultValue(field.getValue(), constructor); // Push default value
                    constructor.visitFieldInsn(Opcodes.PUTFIELD, typeName, field.getKey(), getTypeDescriptor(field.getValue()));
                }
                
                constructor.visitInsn(Opcodes.RETURN);
                constructor.visitMaxs(2, 1); // Ensure enough stack space
                constructor.visitEnd();
                
                typeWriters.put(typeName, cw);
            }

            // Add methods if this type has any
            Map<String, FunctionInfo> methods = typeMethods.get(typeName);
            if (methods != null) {
                for (FunctionInfo method : methods.values()) {
                    generateMethod(cw, typeName, method);
                }
            }
        }
    }

    private void generateFunctions() {
        for (FunctionInfo func : functions.values()) {
            generateStaticMethod(mainClassWriter, func);
        }
    }

    private void generateMethod(ClassWriter cw, String className, FunctionInfo func) {
        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, func.name, func.descriptor, null, null);
        mv.visitCode();
        Map<String, Integer> savedVars = new HashMap<>(localVars);
        Map<String, String> savedDefinedVars = new HashMap<>(definedVariables);
        String savedClassName = currentClassName;
        int savedNextVar = nextVarIndex;
        localVars.clear();
        definedVariables.clear();
        currentClassName = className; // Set current class for field access
        nextVarIndex = 0;
        localVars.put("this", nextVarIndex++);
        
        // Add class fields to the defined variables scope
        Map<String, String> classFields = typeFields.get(className);
        if (classFields != null) {
            for (Map.Entry<String, String> field : classFields.entrySet()) {
                definedVariables.put(field.getKey(), field.getValue());
            }
        }
        
        for (int i = 0; i < func.paramNames.size(); i++) {
            String paramName = func.paramNames.get(i);
            String paramType = func.paramTypes.get(i);
            localVars.put(paramName, nextVarIndex);
            definedVariables.put(paramName, paramType);
            nextVarIndex += (isDoubleSlotType(paramType)) ? 2 : 1;
        }
        gemParser.FunctionDeclarationContext ctx = (gemParser.FunctionDeclarationContext) func.body;
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }
        if ("void".equals(func.returnType)) {
            mv.visitInsn(Opcodes.RETURN);
        } else if (ctx.statement().stream().noneMatch(s -> s.returnStatement() != null)) {
            generateDefaultValue(func.returnType, mv);
            mv.visitInsn(getReturnOpcode(func.returnType));
        }
        mv.visitMaxs(0,0);
        mv.visitEnd();
        localVars = savedVars;
        definedVariables = savedDefinedVars;
        currentClassName = savedClassName;
        nextVarIndex = savedNextVar;
    }

    private void generateStaticMethod(ClassWriter cw, FunctionInfo func) {
        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, func.name, func.descriptor, null, null);
        mv.visitCode();
        Map<String, Integer> savedVars = new HashMap<>(localVars);
        Map<String, String> savedDefinedVars = new HashMap<>(definedVariables);
        int savedNextVar = nextVarIndex;
        localVars.clear();
        definedVariables.clear();
        nextVarIndex = 0;
        for (int i = 0; i < func.paramNames.size(); i++) {
            String paramName = func.paramNames.get(i);
            String paramType = func.paramTypes.get(i);
            localVars.put(paramName, nextVarIndex);
            definedVariables.put(paramName, paramType);
            nextVarIndex += (isDoubleSlotType(paramType)) ? 2 : 1;
        }
        gemParser.FunctionDeclarationContext ctx = (gemParser.FunctionDeclarationContext) func.body;
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }
        if ("void".equals(func.returnType)) {
            mv.visitInsn(Opcodes.RETURN);
        } else if (ctx.statement().stream().noneMatch(s -> s.returnStatement() != null)) {
            generateDefaultValue(func.returnType, mv);
            mv.visitInsn(getReturnOpcode(func.returnType));
        }
        mv.visitMaxs(0,0);
        mv.visitEnd();
        localVars = savedVars;
        definedVariables = savedDefinedVars;
        nextVarIndex = savedNextVar;
    }

    private boolean isDoubleSlotType(String typeName) {
        // In Java, long and double take two local variable slots.
        // Gem does not currently have these, but this is for future-proofing.
        return typeName.equals("long") || typeName.equals("double");
    }


    private void generateProgram(gemParser.ProgramContext ctx, MethodVisitor mv) {
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }
    }

    private void generateStatement(gemParser.StatementContext ctx, MethodVisitor mv) {
        if (ctx.variableDeclaration() != null) {
            generateVariableDeclaration(ctx.variableDeclaration(), mv);
        } else if (ctx.assignment() != null) {
            generateAssignment(ctx.assignment(), mv);
        } else if (ctx.ifStatement() != null) {
            generateIfStatement(ctx.ifStatement(), mv);
        } else if (ctx.forLoop() != null) {
            generateForLoop(ctx.forLoop(), mv);
        } else if (ctx.whileLoop() != null) {
            generateWhileLoop(ctx.whileLoop(), mv);
        } else if (ctx.loop() != null) {
            generateLoop(ctx.loop(), mv);
        } else if (ctx.printStatement() != null) {
            generatePrintStatement(ctx.printStatement(), mv);
        } else if (ctx.readStatement() != null) {
            generateReadStatement(ctx.readStatement(), mv);
        } else if (ctx.expression() != null) {
            String exprType = getExpressionType(ctx.expression());
            generateExpression(ctx.expression(), mv);
            if (!"void".equals(exprType)) {
                if (isDoubleSlotType(exprType)) {
                    mv.visitInsn(Opcodes.POP2);
                } else {
                    mv.visitInsn(Opcodes.POP);
                }
            }
        } else if (ctx.functionCall() != null) {
            generateFunctionCall(ctx.functionCall(), mv);
            String returnType = getFunctionCallReturnType(ctx.functionCall());
            if (!"void".equals(returnType)) {
                if (isDoubleSlotType(returnType)) {
                    mv.visitInsn(Opcodes.POP2);
                } else {
                    mv.visitInsn(Opcodes.POP);
                }
            }
        } else if (ctx.returnStatement() != null) {
            generateReturnStatement(ctx.returnStatement(), mv);
        } else if (ctx.breakStatement() != null) {
            generateBreakStatement(ctx.breakStatement(), mv);
        } else if (ctx.innerFunctionDeclaration() != null) {
            generateInnerFunctionDeclaration(ctx.innerFunctionDeclaration(), mv);
        }
    }

    private void generateInnerFunctionDeclaration(gemParser.InnerFunctionDeclarationContext ctx, MethodVisitor mv) {
        String funcName = ctx.ID().getText();
        String returnType = "void";
        
        if (ctx.type() != null) {
            returnType = getTypeString(ctx.type());
        }
        
        // Build method descriptor
        StringBuilder descriptor = new StringBuilder("(");
        if (ctx.parameterList() != null) {
            for (gemParser.ParameterContext param : ctx.parameterList().parameter()) {
                String paramType = getTypeString(param.type());
                if (param.REF() != null) {
                    paramType += "[]"; // Reference parameters are arrays
                }
                descriptor.append(getTypeDescriptor(paramType));
            }
        }
        descriptor.append(")").append(getTypeDescriptor(returnType));
        
        // Store function info
        FunctionInfo funcInfo = new FunctionInfo(returnType, descriptor.toString());
        functions.put(funcName, funcInfo);
        
        // Generate method
        MethodVisitor funcMv = mainClassWriter.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
                                                           funcName, descriptor.toString(), null, null);
        funcMv.visitCode();
        
        // Set up local variables for parameters
        Map<String, Integer> savedLocalVars = new HashMap<>(localVars);
        Map<String, String> savedDefinedVars = new HashMap<>(definedVariables);
        
        // Don't clear localVars to allow access to outer scope variables (closure)
        int localIndex = localVars.size(); // Start after existing variables
        if (ctx.parameterList() != null) {
            for (gemParser.ParameterContext param : ctx.parameterList().parameter()) {
                String paramName = param.ID().getText();
                String paramType = getTypeString(param.type());
                if (param.REF() != null) {
                    paramType += "[]"; // Reference parameters are arrays
                }
                localVars.put(paramName, localIndex++);
                definedVariables.put(paramName, paramType);
            }
        }
        
        // Generate function body
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, funcMv);
        }
        
        // Add return if needed
        if (returnType.equals("void")) {
            funcMv.visitInsn(Opcodes.RETURN);
        }
        
        funcMv.visitMaxs(0, 0);
        funcMv.visitEnd();
        
        // Restore previous state
        localVars = savedLocalVars;
        definedVariables = savedDefinedVars;
    }

    private void generateVariableDeclaration(gemParser.VariableDeclarationContext ctx, MethodVisitor mv) {
        String varName = ctx.ID().getText();
        String typeName;

        if (ctx.type() != null) {
            typeName = getTypeString(ctx.type());
        } else if (ctx.struct_type() != null) {
            typeName = ctx.struct_type().ID().getText();
        } else {
            typeName = ctx.class_type().ID().getText();
        }

        int varIndex = nextVarIndex;
        nextVarIndex += (isDoubleSlotType(typeName)) ? 2 : 1;
        localVars.put(varName, varIndex);
        definedVariables.put(varName, typeName);


        if (ctx.expression() != null) {
            String exprType = getExpressionType(ctx.expression());
            generateExpression(ctx.expression(), mv);
            
            // Convert integer to number if needed
            if (typeName.equals("number") && exprType.equals("integer")) {
                mv.visitInsn(Opcodes.I2F);
            }
            
            storeVariable(varName, typeName, mv);
        } else if (typeFields.containsKey(typeName) || typeMethods.containsKey(typeName)) {
            mv.visitTypeInsn(Opcodes.NEW, typeName);
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, typeName, "<init>", "()V", false);
            mv.visitVarInsn(Opcodes.ASTORE, varIndex);
        } else {
            generateDefaultValue(typeName, mv);
            storeVariable(varName, typeName, mv);
        }
    }

    private void generateAssignment(gemParser.AssignmentContext ctx, MethodVisitor mv) {
        if (ctx.ID().size() > 1) {
            String objName = ctx.ID(0).getText();
            String fieldName = ctx.ID(1).getText();
            String objType = definedVariables.get(objName);

            if (objType == null) throw new RuntimeException("Object not defined: " + objName);

            loadVariable(objName, objType, mv);
            
            // Check if this is a reference parameter (wrapped in array)
            if (objType.endsWith("[]")) {
                // Unwrap the reference parameter first
                String elementType = objType.substring(0, objType.length() - 2);
                mv.visitInsn(Opcodes.ICONST_0); // Load index 0
                mv.visitInsn(Opcodes.AALOAD); // Get the object from array
                
                // Generate expression and handle type conversion
                String exprType = getExpressionType(ctx.expression(0));
                generateExpression(ctx.expression(0), mv);

                Map<String, String> fields = typeFields.get(elementType);
                if (fields == null || !fields.containsKey(fieldName)) {
                    throw new RuntimeException("Field " + fieldName + " not found in type " + elementType);
                }
                String fieldType = fields.get(fieldName);
                
                // Convert integer to number if needed
                if (fieldType.equals("number") && exprType.equals("integer")) {
                    mv.visitInsn(Opcodes.I2F);
                }
                
                mv.visitFieldInsn(Opcodes.PUTFIELD, elementType, fieldName, getTypeDescriptor(fieldType));
            } else {
                // Generate expression and handle type conversion
                String exprType = getExpressionType(ctx.expression(0));
                generateExpression(ctx.expression(0), mv);

                Map<String, String> fields = typeFields.get(objType);
                if (fields == null || !fields.containsKey(fieldName)) {
                    throw new RuntimeException("Field " + fieldName + " not found in type " + objType);
                }
                String fieldType = fields.get(fieldName);
                
                // Convert integer to number if needed
                if (fieldType.equals("number") && exprType.equals("integer")) {
                    mv.visitInsn(Opcodes.I2F);
                }
                
                mv.visitFieldInsn(Opcodes.PUTFIELD, objType, fieldName, getTypeDescriptor(fieldType));
            }

        } else if (ctx.LBRACK() != null) {
            String arrayName = ctx.ID(0).getText();
            String arrayType = definedVariables.get(arrayName);
            if (arrayType == null || !arrayType.endsWith("[]")) {
                throw new RuntimeException("Variable " + arrayName + " is not an array or not defined.");
            }

            loadVariable(arrayName, arrayType, mv);
            generateExpression(ctx.expression(0), mv);
            generateExpression(ctx.expression(1), mv);

            String elementType = arrayType.substring(0, arrayType.length() - 2);
            mv.visitInsn(getArrayStoreOpcode(elementType));
        } else {
            String varName = ctx.ID(0).getText();
            String typeName = definedVariables.get(varName);
            if (typeName == null) throw new RuntimeException("Variable not defined: " + varName);

            String exprType = getExpressionType(ctx.expression(0));
            generateExpression(ctx.expression(0), mv);
            
            // Convert integer to number if needed
            if (typeName.equals("number") && exprType.equals("integer")) {
                mv.visitInsn(Opcodes.I2F);
            }
            
            storeVariable(varName, typeName, mv);
        }
    }

    private void generateIfStatement(gemParser.IfStatementContext ctx, MethodVisitor mv) {
        // Simplified if-else if-else handling. A more robust solution would map statement blocks to conditions.
        Label endIfChainLabel = new Label();
        List<Label> nextConditionLabels = new ArrayList<>();

        // Create labels for all potential next branches
        for (int i = 0; i <= ctx.expression().size(); i++) { // One more for the final else or end
            nextConditionLabels.add(new Label());
        }

        int statementCounter = 0; // To track statements associated with each block

        // Handle if and else if blocks
        for (int i = 0; i < ctx.expression().size(); i++) {
            if (i > 0) { // For `else if`, label the start of its condition check
                mv.visitLabel(nextConditionLabels.get(i - 1));
            }
            generateExpression(ctx.expression(i), mv);
            mv.visitJumpInsn(Opcodes.IFEQ, nextConditionLabels.get(i)); // If false, jump to next condition/else

            // Execute statements for this block
            // This assumes a certain structure of how statements are direct children or grouped.
            // This part of the logic is complex with ANTLR's generic tree.
            // We need to correctly associate statements with their `if`/`else if` clause.
            // The existing logic for statementBlocks was a good attempt but needs refinement.
            // For this fix, let's assume one statement per block for simplicity,
            // or use a more direct way if parser rules allow easy grouping.

            // Assuming `gemParser.IfStatementContext` structure:
            // IF expr statement+ (ELSE IF expr statement+)* (ELSE statement+)? END IF
            // Or: IF expr THEN statement (ELSE statement)?

            if (ctx.THEN() != null) { // Single line if then (else)
                generateStatement(ctx.statement(statementCounter++), mv);
            } else {
                // Multi-line: find statements before the next ELSE or END
                // This is a placeholder for more complex block handling
                // The key is to iterate ctx.statement() and associate them correctly.
                // The previous attempt at statementBlocks had the right idea.
                // Let's assume for now that the statements list `ctx.statement()` is flat
                // and we consume one per block. This is likely too simple.
                // A better way is to look at the grammar rule's children.
                // `ctx.statement(i)` might not be correct for multi-line blocks.
                if (statementCounter < ctx.statement().size()) { // Simplified: Process one statement for the block
                    generateStatement(ctx.statement(statementCounter++), mv);
                }
            }
            mv.visitJumpInsn(Opcodes.GOTO, endIfChainLabel);
        }

        // Handle the final else block (if any)
        mv.visitLabel(nextConditionLabels.get(ctx.expression().size() - (ctx.expression().isEmpty() ? 0 : 1) )); // Label for after all conditions failed

        // Error was here:
        // C:\Users\Yabuku\Downloads\gem\src\main\java\CodeGenerator.java:571: error: cannot find symbol
        // if(ctx.ELSE() != null && ctx.getChild(ctx.ELSE().getSymbol().getTokenIndex()-1).getText().equals("end") == false ) { // Check if it's a true else, not part of an else if
        //                                             ^ (pointing to getSymbol())
        // symbol:   method getSymbol()
        // location: interface List<TerminalNode>

        boolean hasTrueElse = false;
        if (ctx.ELSE() != null && !ctx.ELSE().isEmpty()) {
            // This logic determines if the *last* ELSE is a true `else` or part of an `else if`
            // It's tricky because `ctx.ELSE()` gives all ELSE tokens.
            // A simple check: if there's an ELSE and its corresponding block of statements exists.
            // The original logic with getChild and getTokenIndex was very fragile.
            // A simpler approach: If there's an ELSE token and more statements left than processed.
            // The error clearly points to calling getSymbol on a List.
            // We need to access a specific TerminalNode from the list first.
            // E.g. ctx.ELSE().get(0).getSymbol() or ctx.ELSE(0).getSymbol() if using specific index method.
            // The problematic line from the build output was:
            // `ctx.getChild(ctx.ELSE().getSymbol().getTokenIndex()-1)`
            // The fix is to operate on an element of the list:
            // `ctx.getChild(ctx.ELSE().get( specific_else_index ).getSymbol().getTokenIndex()-1)`
            // However, the logic for identifying a "true else" block in a flat list of statements is non-trivial.
            // For now, let's assume if there is an ELSE token, and we still have statements in ctx.statement(), it's an else block.
            // This part needs to be more robust based on how ANTLR groups these in the IfStatementContext.
            // If there are statements after all `if`/`else if` blocks have been processed (statementCounter), it's likely the else block.
            // This simplified approach might be incorrect for complex nested structures without explicit grammar rules for blocks.
            if (statementCounter < ctx.statement().size() && ctx.ELSE(ctx.ELSE().size()-1) !=null ) { // Check if there are remaining statements for an else
                // Iterate through remaining statements for the else block
                for (int i = statementCounter; i < ctx.statement().size(); i++) {
                    generateStatement(ctx.statement(i), mv);
                }
            }
        }

        mv.visitLabel(endIfChainLabel);
    }


    private void generateForLoop(gemParser.ForLoopContext ctx, MethodVisitor mv) {
        String loopVar = ctx.ID().getText();
        int varIndex = nextVarIndex++;

        Label loopStart = new Label();
        Label loopEnd = new Label();
        Label prevBreakLabel = currentBreakLabel;
        currentBreakLabel = loopEnd;

        Map<String, Integer> outerScopeVars = new HashMap<>(localVars);
        Map<String, String> outerScopeDefinedVars = new HashMap<>(definedVariables);

        localVars.put(loopVar, varIndex);
        definedVariables.put(loopVar, "integer");

        generateExpression(ctx.expression(0), mv);
        mv.visitVarInsn(Opcodes.ISTORE, varIndex);

        mv.visitLabel(loopStart);

        mv.visitVarInsn(Opcodes.ILOAD, varIndex);
        generateExpression(ctx.expression(1), mv);
        mv.visitJumpInsn(Opcodes.IF_ICMPGT, loopEnd);

        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        mv.visitIincInsn(varIndex, 1);
        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        mv.visitLabel(loopEnd);
        currentBreakLabel = prevBreakLabel;

        localVars = outerScopeVars;
        definedVariables = outerScopeDefinedVars;
        // nextVarIndex is not decremented here, it's a simple allocation strategy
    }

    private void generateWhileLoop(gemParser.WhileLoopContext ctx, MethodVisitor mv) {
        Label loopStart = new Label();
        Label loopEnd = new Label();
        Label prevBreakLabel = currentBreakLabel;
        currentBreakLabel = loopEnd;

        mv.visitLabel(loopStart);
        generateExpression(ctx.expression(), mv);
        mv.visitJumpInsn(Opcodes.IFEQ, loopEnd);

        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        mv.visitJumpInsn(Opcodes.GOTO, loopStart);
        mv.visitLabel(loopEnd);
        currentBreakLabel = prevBreakLabel;
    }

    private void generateLoop(gemParser.LoopContext ctx, MethodVisitor mv) {
        Label loopStart = new Label();
        Label loopEnd = new Label();
        Label prevBreakLabel = currentBreakLabel;
        currentBreakLabel = loopEnd;

        mv.visitLabel(loopStart);

        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        mv.visitJumpInsn(Opcodes.GOTO, loopStart);
        mv.visitLabel(loopEnd);
        currentBreakLabel = prevBreakLabel;
    }


    private void generateBreakStatement(gemParser.BreakStatementContext ctx, MethodVisitor mv) {
        if (currentBreakLabel == null) {
            throw new UnsupportedOperationException("Break statement found outside of a loop.");
        }
        mv.visitJumpInsn(Opcodes.GOTO, currentBreakLabel);
    }

    private void generateReturnStatement(gemParser.ReturnStatementContext ctx, MethodVisitor mv) {
        String exprType = getExpressionType(ctx.expression());
        generateExpression(ctx.expression(), mv);
        mv.visitInsn(getReturnOpcode(exprType));
    }

    private void generatePrintStatement(gemParser.PrintStatementContext ctx, MethodVisitor mv) {
        System.out.println("Generating print statement: " + ctx.expression().getText());
        mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
        String exprType = getExpressionType(ctx.expression());
        System.out.println("Print expression type: " + exprType);
        
        // Handle string concatenation with + operator
        if (ctx.expression().logicalExpression().comparisonExpression().size() == 1 &&
            ctx.expression().logicalExpression().comparisonExpression(0).additiveExpression().size() > 1) {
            
            // Create a StringBuilder
            mv.visitTypeInsn(Opcodes.NEW, "java/lang/StringBuilder");
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
            
            // Process each part of the concatenation
            gemParser.AdditiveExpressionContext addExpr = ctx.expression().logicalExpression().comparisonExpression(0).additiveExpression(0);
            for (int i = 0; i < addExpr.multiplicativeExpression().size(); i++) {
                if (i > 0) {
                    String op = addExpr.getChild(i * 2 - 1).getText();
                    if (!op.equals("+")) {
                        // If not concatenation, fall back to normal print
                         mv.visitInsn(Opcodes.POP); // Pop the StringBuilder
                         generateExpression(ctx.expression(), mv);
                         String printlnDescriptor = getPrintDescriptor(exprType, mv);
                         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", printlnDescriptor, false);
                         return;
                    }
                }
                
                // Generate code for this part of the expression
                String partType = getMessageExpressionType(addExpr.multiplicativeExpression(i).messageExpression(0));
                System.out.println("Concatenation part type: " + partType + " for expression: " + 
                                  addExpr.multiplicativeExpression(i).messageExpression(0).getText());
                
                // Generate the message expression (which might be a message passing operation)
                generateMessageExpression(addExpr.multiplicativeExpression(i).messageExpression(0), mv);
                
                // Convert to string and append
                if (!partType.equals("string")) {
                    convertToString(mv, partType);
                }
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            }
            
            // Convert StringBuilder to String
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
        } else {
            // Normal print without string concatenation
            generateExpression(ctx.expression(), mv); // Value is on stack
            String printlnDescriptor;
            // Ensure the value on stack is a String if println expects one for the type
            switch (exprType) {
                case "integer": 
                    printlnDescriptor = "(I)V"; 
                    break;
                case "number":  
                    printlnDescriptor = "(F)V"; 
                    break;
                case "boolean": 
                    printlnDescriptor = "(Z)V"; 
                    break;
                case "char":    
                    printlnDescriptor = "(C)V"; 
                    break;
                case "string":  
                    printlnDescriptor = "(Ljava/lang/String;)V"; 
                    break;
                default: // For objects (including message types) and arrays
                    // Convert the object/array on stack to its String representation
                    mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/String", "valueOf", "(Ljava/lang/Object;)Ljava/lang/String;", false);
                    printlnDescriptor = "(Ljava/lang/String;)V";
                    break;
            }
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", printlnDescriptor, false);
        }
    }
    
    private String getPrintDescriptor(String exprType, MethodVisitor mv) {
        switch (exprType) {
            case "integer": return "(I)V";
            case "number":  return "(F)V";
            case "boolean": return "(Z)V";
            case "char":    return "(C)V";
            case "string":  return "(Ljava/lang/String;)V";
            default:
                if (exprType.endsWith("[]")) { // Handle arrays by converting to string
                    mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/util/Arrays", "toString", "([Ljava/lang/Object;)Ljava/lang/String;", false);
                    // This assumes object array; primitive arrays need different `Arrays.toString` overloads
                } else { // Other objects, use String.valueOf
                    mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/String", "valueOf", "(Ljava/lang/Object;)Ljava/lang/String;", false);
                }
                return "(Ljava/lang/String;)V";
        }
    }


    private void generateReadStatement(gemParser.ReadStatementContext ctx, MethodVisitor mv) {
        String funcName = ctx.ID().getText();

        mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
        mv.visitInsn(Opcodes.DUP);
        mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "in", "Ljava/io/InputStream;");
        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/util/Scanner", "<init>", "(Ljava/io/InputStream;)V", false);

        if (funcName.equals("read_integer")) {
            generateIntegerInputWithErrorHandling(mv); // The result int is left on stack
        } else if (funcName.equals("read_line")) {
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/util/Scanner", "nextLine", "()Ljava/lang/String;", false);
        } else {
            throw new UnsupportedOperationException("Unsupported read function: " + funcName);
        }
    }

    private void generateExpression(gemParser.ExpressionContext ctx, MethodVisitor mv) {
        generateLogicalExpression(ctx.logicalExpression(), mv);
    }

    private void generateLogicalExpression(gemParser.LogicalExpressionContext ctx, MethodVisitor mv) {
        if (ctx.comparisonExpression().size() == 1) {
            generateComparisonExpression(ctx.comparisonExpression(0), mv);
            return;
        }
        // Simplified: evaluate left, then right, then apply op. Short-circuiting needs labels.
        generateComparisonExpression(ctx.comparisonExpression(0), mv);
        for (int i = 1; i < ctx.comparisonExpression().size(); i++) {
            generateComparisonExpression(ctx.comparisonExpression(i), mv);
            if (ctx.AND(i-1) != null) mv.visitInsn(Opcodes.IAND);
            else if (ctx.OR(i-1) != null) mv.visitInsn(Opcodes.IOR);
        }
    }

    private void generateComparisonExpression(gemParser.ComparisonExpressionContext ctx, MethodVisitor mv) {
        if (ctx.additiveExpression().size() == 1) {
            generateAdditiveExpression(ctx.additiveExpression(0), mv);
            return;
        }

        String leftType = getAdditiveExpressionType(ctx.additiveExpression(0));
        String rightType = getAdditiveExpressionType(ctx.additiveExpression(1));

        generateAdditiveExpression(ctx.additiveExpression(0), mv);
        if (leftType.equals("integer") && rightType.equals("number")) {
            mv.visitInsn(Opcodes.I2F); // Promote left to float
            leftType = "number";
        }

        generateAdditiveExpression(ctx.additiveExpression(1), mv);
        if (rightType.equals("integer") && leftType.equals("number")) {
            mv.visitInsn(Opcodes.I2F); // Promote right to float
        }


        String op = ctx.getChild(1).getText();
        Label trueLabel = new Label();
        Label endLabel = new Label();
        int jumpOpcode = -1;

        if (leftType.equals("number") || rightType.equals("number")) { // Float comparison
            mv.visitInsn(Opcodes.FCMPG); // Pushes 1 if val1 > val2, 0 if val1 == val2, -1 if val1 < val2
            switch (op) {
                case "<": mv.visitJumpInsn(Opcodes.IFLT, trueLabel); break;
                case ">": mv.visitJumpInsn(Opcodes.IFGT, trueLabel); break;
                case "<=": mv.visitJumpInsn(Opcodes.IFLE, trueLabel); break;
                case ">=": mv.visitJumpInsn(Opcodes.IFGE, trueLabel); break;
                case "==": mv.visitJumpInsn(Opcodes.IFEQ, trueLabel); break;
                case "!=": mv.visitJumpInsn(Opcodes.IFNE, trueLabel); break;
                default: throw new UnsupportedOperationException("Unsupported float comparison: " + op);
            }
        } else if (leftType.equals("string")) { // String comparison
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "equals", "(Ljava/lang/Object;)Z", false);
            if (op.equals("==")) mv.visitJumpInsn(Opcodes.IFNE, trueLabel); // equals returns 1 if true
            else if (op.equals("!=")) mv.visitJumpInsn(Opcodes.IFEQ, trueLabel); // equals returns 0 if false
            else throw new UnsupportedOperationException("Only '==' and '!=' supported for strings.");
        } else { // Integer/Boolean comparison
            switch (op) {
                case "<": jumpOpcode = Opcodes.IF_ICMPLT; break;
                case ">": jumpOpcode = Opcodes.IF_ICMPGT; break;
                case "<=": jumpOpcode = Opcodes.IF_ICMPLE; break;
                case ">=": jumpOpcode = Opcodes.IF_ICMPGE; break;
                case "==": jumpOpcode = Opcodes.IF_ICMPEQ; break;
                case "!=": jumpOpcode = Opcodes.IF_ICMPNE; break;
                default: throw new UnsupportedOperationException("Unsupported int/bool comparison: " + op);
            }
            mv.visitJumpInsn(jumpOpcode, trueLabel);
        }

        mv.visitInsn(Opcodes.ICONST_0); // False
        mv.visitJumpInsn(Opcodes.GOTO, endLabel);
        mv.visitLabel(trueLabel);
        mv.visitInsn(Opcodes.ICONST_1); // True
        mv.visitLabel(endLabel);
    }


    private void generateAdditiveExpression(gemParser.AdditiveExpressionContext ctx, MethodVisitor mv) {
        generateMultiplicativeExpression(ctx.multiplicativeExpression(0), mv);
        String currentType = getMultiplicativeExpressionType(ctx.multiplicativeExpression(0));

        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            String rightOperandType = getMultiplicativeExpressionType(ctx.multiplicativeExpression(i));
            // Type promotion logic
            if (currentType.equals("string") || rightOperandType.equals("string")) {
                // Convert non-string to string if necessary for concatenation
                if (!currentType.equals("string")) {
                    convertToString(mv, currentType);
                }
                generateMultiplicativeExpression(ctx.multiplicativeExpression(i), mv);
                if (!rightOperandType.equals("string")) {
                    convertToString(mv, rightOperandType);
                }
                // Concatenate using StringBuilder
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "concat", "(Ljava/lang/String;)Ljava/lang/String;", false);
                currentType = "string";
            } else if (currentType.equals("number") || rightOperandType.equals("number")) {
                if (currentType.equals("integer")) mv.visitInsn(Opcodes.I2F);
                generateMultiplicativeExpression(ctx.multiplicativeExpression(i), mv);
                if (rightOperandType.equals("integer")) mv.visitInsn(Opcodes.I2F);
                currentType = "number";
                String op = ctx.getChild(i * 2 - 1).getText();
                if (op.equals("+")) mv.visitInsn(Opcodes.FADD); else mv.visitInsn(Opcodes.FSUB);
            } else { // Both are integer
                generateMultiplicativeExpression(ctx.multiplicativeExpression(i), mv);
                String op = ctx.getChild(i * 2 - 1).getText();
                if (op.equals("+")) mv.visitInsn(Opcodes.IADD); else mv.visitInsn(Opcodes.ISUB);
            }
        }
    }
    private void convertToString(MethodVisitor mv, String type) {
        // Converts the value on top of the stack to a String
        switch (type) {
            case "integer":
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/String", "valueOf", "(I)Ljava/lang/String;", false);
                break;
            case "number":
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/String", "valueOf", "(F)Ljava/lang/String;", false);
                break;
            case "boolean":
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/String", "valueOf", "(Z)Ljava/lang/String;", false);
                break;
            case "char":
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/String", "valueOf", "(C)Ljava/lang/String;", false);
                break;
            case "string":
                // Already a string, do nothing
                break;
            default: // For objects (including message types) and arrays
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/String", "valueOf", "(Ljava/lang/Object;)Ljava/lang/String;", false);
                break;
        }
    }


    private void generateMultiplicativeExpression(gemParser.MultiplicativeExpressionContext ctx, MethodVisitor mv) {
        generateMessageExpression(ctx.messageExpression(0), mv);
        String currentType = getMessageExpressionType(ctx.messageExpression(0));

        for (int i = 1; i < ctx.messageExpression().size(); i++) {
            String rightType = getMessageExpressionType(ctx.messageExpression(i));
            if (currentType.equals("integer") && rightType.equals("number")) {
                mv.visitInsn(Opcodes.I2F); currentType = "number";
            }
            generateMessageExpression(ctx.messageExpression(i), mv);
            if (rightType.equals("integer") && currentType.equals("number")) {
                mv.visitInsn(Opcodes.I2F);
            }

            String op = ctx.getChild(i * 2 - 1).getText();
            if (currentType.equals("number")) {
                switch (op) {
                    case "*": mv.visitInsn(Opcodes.FMUL); break;
                    case "/": mv.visitInsn(Opcodes.FDIV); break;
                    case "%": mv.visitInsn(Opcodes.FREM); break;
                }
            } else { // integer
                switch (op) {
                    case "*": mv.visitInsn(Opcodes.IMUL); break;
                    case "/": mv.visitInsn(Opcodes.IDIV); break;
                    case "%": mv.visitInsn(Opcodes.IREM); break;
                }
            }
        }
    }


    private void generateMessageExpression(gemParser.MessageExpressionContext ctx, MethodVisitor mv) {
        // Handle array access
        if (ctx.LBRACK() != null) {
            // Generate the base message expression (array variable)
            generateMessageExpression(ctx.messageExpression(), mv);
            
            // Generate the index expression
            generateExpression(ctx.expression(), mv);
            
            // Get the array type to determine the correct load instruction
            String arrayType = getMessageExpressionType(ctx.messageExpression());
            
            // Array access operation
            if (arrayType != null && arrayType.equals("string[]")) {
                mv.visitInsn(Opcodes.AALOAD); // Load reference from array
            } else if (arrayType != null && arrayType.equals("integer[]")) {
                mv.visitInsn(Opcodes.IALOAD); // Load int from array
            } else if (arrayType != null && arrayType.equals("number[]")) {
                mv.visitInsn(Opcodes.FALOAD); // Load float from array
            } else if (arrayType != null && arrayType.equals("boolean[]")) {
                mv.visitInsn(Opcodes.BALOAD); // Load boolean from array
            } else if (arrayType != null && arrayType.equals("char[]")) {
                mv.visitInsn(Opcodes.CALOAD); // Load char from array
            } else {
                 // Handle potential error or default
                 mv.visitInsn(Opcodes.AALOAD); // Default to reference load
            }
        } else if (ctx.ARROW() != null) {
            String objType = getMessageExpressionType(ctx.messageExpression());
            String methodName = ctx.ID().getText();
            
            // For message passing, we need to find the method in the target class
            Map<String, FunctionInfo> methodMap = typeMethods.getOrDefault(objType, Collections.emptyMap());
            FunctionInfo methodInfo = methodMap.get(methodName);
            
            if (methodInfo == null) {
                throw new RuntimeException("Method " + methodName + " not found in message type " + objType);
            }
            
            // Log message passing operation for debugging
            System.out.println("Processing message passing to " + objType + "." + methodName);
            
            // For message passing, we need to prepare the arguments
            if (ctx.argumentList() != null) {
                for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                    generateExpression(arg.expression(), mv);
                }
            }
            
            // Generate the method call - for message passing we use INVOKEVIRTUAL
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, objType, methodName, methodInfo.descriptor, false);
        } else if (ctx.DOT() != null) {
            String objType = getMessageExpressionType(ctx.messageExpression());
            String memberName = ctx.ID().getText();
            if (ctx.LPAREN() != null) {
                FunctionInfo methodInfo = typeMethods.getOrDefault(objType, Collections.emptyMap()).get(memberName);
                if (methodInfo == null) throw new RuntimeException("Method " + memberName + " not found in " + objType);
                if (ctx.argumentList() != null) {
                    for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                        generateExpression(arg.expression(), mv);
                    }
                }
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, objType, memberName, methodInfo.descriptor, false);
            } else {
                // Check if this is a reference parameter (wrapped in array)
                if (objType.endsWith("[]")) {
                    // Unwrap the reference parameter first
                    String elementType = objType.substring(0, objType.length() - 2);
                    mv.visitInsn(Opcodes.ICONST_0); // Load index 0
                    mv.visitInsn(Opcodes.AALOAD); // Get the object from array
                    
                    Map<String, String> fields = typeFields.get(elementType);
                    if (fields == null || !fields.containsKey(memberName)) {
                        throw new RuntimeException("Field " + memberName + " not found in " + elementType);
                    }
                    mv.visitFieldInsn(Opcodes.GETFIELD, elementType, memberName, getTypeDescriptor(fields.get(memberName)));
                } else {
                    Map<String, String> fields = typeFields.get(objType);
                    if (fields == null || !fields.containsKey(memberName)) {
                        throw new RuntimeException("Field " + memberName + " not found in " + objType);
                    }
                    mv.visitFieldInsn(Opcodes.GETFIELD, objType, memberName, getTypeDescriptor(fields.get(memberName)));
                }
            }
        } else if (ctx.primaryExpression() != null) {
            // Not array access, arrow, or dot - generate primary expression normally
            generatePrimaryExpression(ctx.primaryExpression(), mv);
        }
    }


    private void generatePrimaryExpression(gemParser.PrimaryExpressionContext ctx, MethodVisitor mv) {
        if (ctx.ID() != null && ctx.LPAREN() == null) {
            String varName = ctx.ID().getText();
            
            // Check if it's a function first
            if (functions.containsKey(varName)) {
                throw new RuntimeException("Function call missing parentheses: " + varName);
            }
            
            if (!definedVariables.containsKey(varName)) {
                throw new RuntimeException("Variable not found: " + varName);
            }
            
            
            // Check if this is a field access within a class method
            if (localVars.containsKey("this") && !localVars.containsKey(varName)) {
                // This is a field access - generate this.field
                mv.visitVarInsn(Opcodes.ALOAD, 0); // Load 'this'
                String fieldType = definedVariables.get(varName);
                mv.visitFieldInsn(Opcodes.GETFIELD, currentClassName, varName, getTypeDescriptor(fieldType));
            } else {
                loadVariable(varName, definedVariables.get(varName), mv);
            }
        } else if (ctx.literal() != null) {
            generateLiteral(ctx.literal(), mv);
        } else if (ctx.expression() != null) {
            generateExpression(ctx.expression(), mv);
        } else if (ctx.ID() != null && ctx.LPAREN() != null) {
            // This case should be handled by generateFunctionCall if it's a standalone statement,
            // or if it's part of a larger expression, its return value is used.
            // The logic here assumes it's called as part of an expression.
            // We need a way to distinguish this from a standalone function call statement.
            // For now, assuming this specific primary expression variant is a function call whose value is needed.
            String funcName = ctx.ID().getText();
            FunctionInfo funcInfo = functions.get(funcName); // Check static functions
            if (funcInfo != null) {
                if (ctx.argumentList() != null) {
                    for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                        generateExpression(arg.expression(), mv);
                    }
                }
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, currentClassName, funcName, funcInfo.descriptor, false);
            } else {
                // Handle built-in functions
                if (funcName.equals("split") && ctx.argumentList() != null && ctx.argumentList().argument().size() == 2) {
                    generateExpression(ctx.argumentList().argument(0).expression(), mv); // string
                    generateExpression(ctx.argumentList().argument(1).expression(), mv); // delimiter
                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "split", "(Ljava/lang/String;)[Ljava/lang/String;", false);
                } else if (funcName.equals("length") && ctx.argumentList() != null && ctx.argumentList().argument().size() == 1) {
                    generateExpression(ctx.argumentList().argument(0).expression(), mv);
                    String argType = getExpressionType(ctx.argumentList().argument(0).expression());
                    if (argType.endsWith("[]")) mv.visitInsn(Opcodes.ARRAYLENGTH);
                    else mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "length", "()I", false);
                } else if (funcName.equals("uppercase") && ctx.argumentList() != null && ctx.argumentList().argument().size() == 1) {
                    generateExpression(ctx.argumentList().argument(0).expression(), mv);
                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "toUpperCase", "()Ljava/lang/String;", false);
                } else if (funcName.equals("read_integer")) {
                    generateIntegerInputWithErrorHandling(mv);
                } else if (funcName.equals("read_line")) {
                    mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
                    mv.visitInsn(Opcodes.DUP);
                    mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "in", "Ljava/io/InputStream;");
                    mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/util/Scanner", "<init>", "(Ljava/io/InputStream;)V", false);
                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/util/Scanner", "nextLine", "()Ljava/lang/String;", false);
                } else {
                    throw new UnsupportedOperationException("Function call in primary expression not fully resolved: " + funcName);
                }
            }
        }
    }


    private void generateFunctionCall(gemParser.FunctionCallContext ctx, MethodVisitor mv) {
        String funcName = ctx.ID(0).getText();

        if (ctx.ID().size() == 1) { // Simple function call (static or global)
            if (funcName.equals("read_integer")) {
                generateIntegerInputWithErrorHandling(mv);
            } else if (funcName.equals("read_line")) {
                mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
                mv.visitInsn(Opcodes.DUP);
                mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "in", "Ljava/io/InputStream;");
                mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/util/Scanner", "<init>", "(Ljava/io/InputStream;)V", false);
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/util/Scanner", "nextLine", "()Ljava/lang/String;", false);
            } else if (funcName.equals("split") && ctx.argumentList() != null && ctx.argumentList().argument().size() == 2) {
                generateExpression(ctx.argumentList().argument(0).expression(), mv); // string
                generateExpression(ctx.argumentList().argument(1).expression(), mv); // delimiter
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "split", "(Ljava/lang/String;)[Ljava/lang/String;", false);
            } else if (funcName.equals("length") && ctx.argumentList() != null && ctx.argumentList().argument().size() == 1) {
                generateExpression(ctx.argumentList().argument(0).expression(), mv);
                String argType = getExpressionType(ctx.argumentList().argument(0).expression());
                if (argType.endsWith("[]")) mv.visitInsn(Opcodes.ARRAYLENGTH);
                else mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "length", "()I", false);
            } else if (funcName.equals("uppercase") && ctx.argumentList() != null && ctx.argumentList().argument().size() == 1) {
                generateExpression(ctx.argumentList().argument(0).expression(), mv);
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "toUpperCase", "()Ljava/lang/String;", false);
            } else if (functions.containsKey(funcName)) {
                FunctionInfo func = functions.get(funcName);
                if (ctx.argumentList() != null) {
                    int argIndex = 0;
                    for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                        if (arg.REF() != null) {
                            // This is a reference parameter - wrap in array
                            String varName = arg.expression().logicalExpression().comparisonExpression(0)
                                .additiveExpression(0).multiplicativeExpression(0).messageExpression(0)
                                .primaryExpression().ID().getText();
                            String varType = definedVariables.get(varName);
                            
                            // Create array of size 1 and store the variable
                            mv.visitInsn(Opcodes.ICONST_1);
                            if (isPrimitiveGemType(varType)) {
                                mv.visitIntInsn(Opcodes.NEWARRAY, getPrimitiveArrayTypecode(varType));
                            } else {
                                mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(varType));
                            }
                            mv.visitInsn(Opcodes.DUP);
                            mv.visitInsn(Opcodes.ICONST_0);
                            loadVariable(varName, varType, mv);
                            if (isPrimitiveGemType(varType)) {
                                switch (varType) {
                                    case "integer": mv.visitInsn(Opcodes.IASTORE); break;
                                    case "number": mv.visitInsn(Opcodes.FASTORE); break;
                                    case "boolean": mv.visitInsn(Opcodes.BASTORE); break;
                                    case "char": mv.visitInsn(Opcodes.CASTORE); break;
                                    default: mv.visitInsn(Opcodes.AASTORE); break;
                                }
                            } else {
                                mv.visitInsn(Opcodes.AASTORE);
                            }
                        } else {
                            generateExpression(arg.expression(), mv);
                        }
                        argIndex++;
                    }
                }
                mv.visitMethodInsn(Opcodes.INVOKESTATIC, currentClassName, funcName, func.descriptor, false);
                
                // After function call, extract modified values from reference arrays
                if (ctx.argumentList() != null) {
                    // We need to store the function's return value temporarily if it's not void
                    String returnType = functions.get(funcName).returnType;
                    int tempReturnVarIndex = -1;
                    
                    if (!"void".equals(returnType)) {
                        tempReturnVarIndex = nextVarIndex++;
                        if (isDoubleSlotType(returnType)) {
                            nextVarIndex++;
                        }
                        storeVariable("__temp_return", returnType, mv);
                    }
                    
                    // Process each reference parameter to extract modified values
                    for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                        if (arg.REF() != null) {
                            // Extract the modified value from the array and store back to variable
                            String varName = arg.expression().logicalExpression().comparisonExpression(0)
                                .additiveExpression(0).multiplicativeExpression(0).messageExpression(0)
                                .primaryExpression().ID().getText();
                            String varType = definedVariables.get(varName);
                            int varIndex = localVars.get(varName);
                            
                            // Create a new array reference for the parameter
                            mv.visitInsn(Opcodes.ICONST_1);
                            if (isPrimitiveGemType(varType)) {
                                mv.visitIntInsn(Opcodes.NEWARRAY, getPrimitiveArrayTypecode(varType));
                            } else {
                                mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(varType));
                            }
                            
                            // Store this array in a temporary variable
                            int tempArrayIndex = nextVarIndex++;
                            mv.visitVarInsn(Opcodes.ASTORE, tempArrayIndex);
                            
                            // Load the array
                            mv.visitVarInsn(Opcodes.ALOAD, tempArrayIndex);
                            mv.visitInsn(Opcodes.ICONST_0);
                            
                            // Load the original variable
                            loadVariable(varName, varType, mv);
                            
                            // Store it in the array
                            if (isPrimitiveGemType(varType)) {
                                switch (varType) {
                                    case "integer": mv.visitInsn(Opcodes.IASTORE); break;
                                    case "number": mv.visitInsn(Opcodes.FASTORE); break;
                                    case "boolean": mv.visitInsn(Opcodes.BASTORE); break;
                                    case "char": mv.visitInsn(Opcodes.CASTORE); break;
                                    default: mv.visitInsn(Opcodes.AASTORE); break;
                                }
                            } else {
                                mv.visitInsn(Opcodes.AASTORE);
                            }
                            
                            // Call the function again with this reference
                            mv.visitVarInsn(Opcodes.ALOAD, tempArrayIndex);
                            mv.visitMethodInsn(Opcodes.INVOKESTATIC, currentClassName, funcName, func.descriptor, false);
                            
                            // Pop the return value if not void
                            if (!"void".equals(returnType)) {
                                if (isDoubleSlotType(returnType)) {
                                    mv.visitInsn(Opcodes.POP2);
                                } else {
                                    mv.visitInsn(Opcodes.POP);
                                }
                            }
                            
                            // Extract the modified value from the array
                            mv.visitVarInsn(Opcodes.ALOAD, tempArrayIndex);
                            mv.visitInsn(Opcodes.ICONST_0);
                            
                            // Load the element from the array
                            if (isPrimitiveGemType(varType)) {
                                switch (varType) {
                                    case "integer": mv.visitInsn(Opcodes.IALOAD); break;
                                    case "number": mv.visitInsn(Opcodes.FALOAD); break;
                                    case "boolean": mv.visitInsn(Opcodes.BALOAD); break;
                                    case "char": mv.visitInsn(Opcodes.CALOAD); break;
                                    default: mv.visitInsn(Opcodes.AALOAD); break;
                                }
                            } else {
                                mv.visitInsn(Opcodes.AALOAD);
                            }
                            
                            // Store it back to the original variable
                            storeVariable(varName, varType, mv);
                        }
                    }
                    
                    // Restore the function's return value if needed
                    if (tempReturnVarIndex != -1) {
                        loadVariable("__temp_return", returnType, mv);
                    }
                }
            } else {
                throw new UnsupportedOperationException("Function not found: " + funcName);
            }
        } else { // Method call: obj.method() or obj->method()
            String objName = ctx.ID(0).getText();
            String methodName = ctx.ID(1).getText();
            String objType = definedVariables.get(objName);
            if (objType == null) throw new RuntimeException("Object " + objName + " not found.");

            loadVariable(objName, objType, mv); // Load object instance

            // Check if this is a message passing call (with arrow operator)
            boolean isMessagePassing = ctx.ARROW() != null;
            
            // For message passing between objects, we need to find the method in the target class
            // For regular method calls, we find the method in the object's class
            Map<String, FunctionInfo> methodMap = typeMethods.getOrDefault(objType, Collections.emptyMap());
            FunctionInfo methodInfo = methodMap.get(methodName);
            
            if (methodInfo == null) {
                // If the method isn't found in the object's class, it might be a method in a parent class
                // or it might be an error. For now, we'll throw an error.
                throw new RuntimeException("Method " + methodName + " not found in " + objType);
            }

            if (ctx.argumentList() != null) {
                for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                    generateExpression(arg.expression(), mv);
                }
            }
            
            // For message passing, we use the same bytecode as regular method calls
            // The difference is semantic - message passing is used for communication between objects
            // that are marked as message types
            if (isMessagePassing) {
                System.out.println("Processing message passing from " + objName + " to method " + methodName);
                System.out.println("Method descriptor: " + methodInfo.descriptor);
                System.out.println("Return type: " + methodInfo.returnType);
                
                // Additional logging for message passing to help with debugging
                if (typeFields.containsKey(objType)) {
                    System.out.println("Message type " + objType + " has fields: " + typeFields.get(objType).keySet());
                }
            }
            
            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, objType, methodName, methodInfo.descriptor, false);
        }
    }


    private void generateLiteral(gemParser.LiteralContext ctx, MethodVisitor mv) {
        if (ctx.INTEGER_LITERAL() != null) {
            mv.visitLdcInsn(Integer.parseInt(ctx.INTEGER_LITERAL().getText()));
        } else if (ctx.FLOAT_LITERAL() != null) {
            mv.visitLdcInsn(Float.parseFloat(ctx.FLOAT_LITERAL().getText()));
        } else if (ctx.STRING_LITERAL() != null) {
            mv.visitLdcInsn(ctx.STRING_LITERAL().getText().substring(1, ctx.STRING_LITERAL().getText().length() - 1));
        } else if (ctx.CHAR_LITERAL() != null) {
            mv.visitLdcInsn(ctx.CHAR_LITERAL().getText().charAt(1));
        } else if (ctx.BOOLEAN_LITERAL() != null) {
            mv.visitInsn(ctx.BOOLEAN_LITERAL().getText().equals("yes") ? Opcodes.ICONST_1 : Opcodes.ICONST_0);
        } else if (ctx.arrayLiteral() != null) {
            generateArrayLiteral(ctx.arrayLiteral(), mv);
        }
    }

    private void generateArrayLiteral(gemParser.ArrayLiteralContext ctx, MethodVisitor mv) {
        int size = ctx.expression().size();
        mv.visitIntInsn(Opcodes.SIPUSH, size);

        if (size > 0) {
            String elementType = getExpressionType(ctx.expression(0));
            String baseElementType = elementType.endsWith("[]") ? elementType.substring(0, elementType.length() - 2) : elementType;

            if (isPrimitiveGemType(baseElementType)) {
                mv.visitIntInsn(Opcodes.NEWARRAY, getPrimitiveArrayTypecode(baseElementType));
            } else {
                mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(baseElementType));
            }

            for (int i = 0; i < size; i++) {
                mv.visitInsn(Opcodes.DUP);
                mv.visitIntInsn(Opcodes.SIPUSH, i);
                generateExpression(ctx.expression(i), mv);
                mv.visitInsn(getArrayStoreOpcode(baseElementType));
            }
        } else {
            mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object"); // Default for empty array
        }
    }

    private void loadVariable(String name, String type, MethodVisitor mv) {
        if (!localVars.containsKey(name)) throw new RuntimeException("Var not found: " + name);
        int index = localVars.get(name);
        switch (type) {
            case "integer", "boolean", "char": mv.visitVarInsn(Opcodes.ILOAD, index); break;
            case "number": mv.visitVarInsn(Opcodes.FLOAD, index); break;
            default: mv.visitVarInsn(Opcodes.ALOAD, index); break;
        }
    }

    private void storeVariable(String name, String type, MethodVisitor mv) {
        if (!localVars.containsKey(name)) throw new RuntimeException("Var not declared: " + name);
        int index = localVars.get(name);
        switch (type) {
            case "integer", "boolean", "char": mv.visitVarInsn(Opcodes.ISTORE, index); break;
            case "number": mv.visitVarInsn(Opcodes.FSTORE, index); break;
            default: mv.visitVarInsn(Opcodes.ASTORE, index); break;
        }
    }

    private void generateDefaultValue(String type, MethodVisitor mv) {
        switch (type) {
            case "integer", "boolean", "char": mv.visitInsn(Opcodes.ICONST_0); break;
            case "number": mv.visitInsn(Opcodes.FCONST_0); break;
            case "void": break;
            default: mv.visitInsn(Opcodes.ACONST_NULL); break;
        }
    }

    private String getTypeDescriptor(String type) {
        if (type.endsWith("[]")) {
            return "[" + getTypeDescriptor(type.substring(0, type.length() - 2));
        }
        switch (type) {
            case "integer": return "I";
            case "boolean": return "Z";
            case "char": return "C";
            case "number": return "F";
            case "string": return "Ljava/lang/String;";
            case "void": return "V";
            default: return "L" + type + ";";
        }
    }

    private boolean isPrimitiveGemType(String typeName) {
        String baseType = typeName.endsWith("[]") ? typeName.substring(0, typeName.length() - 2) : typeName;
        return switch (baseType) {
            case "integer", "number", "boolean", "char" -> true;
            default -> false;
        };
    }

    private int getPrimitiveArrayTypecode(String baseType) {
        return switch (baseType) {
            case "integer" -> Opcodes.T_INT;
            case "number" -> Opcodes.T_FLOAT;
            case "boolean" -> Opcodes.T_BOOLEAN;
            case "char" -> Opcodes.T_CHAR;
            default -> throw new UnsupportedOperationException("Unsupported primitive for NEWARRAY: " + baseType);
        };
    }

    private String getInternalName(String typeName) {
        String baseType = typeName.endsWith("[]") ? typeName.substring(0, typeName.length() - 2) : typeName;
        return switch (baseType) {
            case "string" -> "java/lang/String";
            default -> baseType;
        };
    }

    private int getArrayLoadOpcode(String elementType) {
        return switch (elementType) {
            case "integer" -> Opcodes.IALOAD;
            case "number" -> Opcodes.FALOAD;
            case "boolean" -> Opcodes.BALOAD;
            case "char" -> Opcodes.CALOAD;
            default -> Opcodes.AALOAD;
        };
    }

    private int getArrayStoreOpcode(String elementType) {
        return switch (elementType) {
            case "integer" -> Opcodes.IASTORE;
            case "number" -> Opcodes.FASTORE;
            case "boolean" -> Opcodes.BASTORE;
            case "char" -> Opcodes.CASTORE;
            default -> Opcodes.AASTORE;
        };
    }

    // Corrected getReturnOpcode method using a traditional switch statement
    private int getReturnOpcode(String type) {
        switch (type) {
            case "integer":
            case "boolean":
            case "char":
                return Opcodes.IRETURN;
            case "number":
                return Opcodes.FRETURN;
            case "void":
                return Opcodes.RETURN;
            default: // string, array, object
                return Opcodes.ARETURN;
        }
    }


    private String getTypeString(gemParser.TypeContext ctx) {
        if (ctx == null) return "void";
        if (ctx.INTEGER_TYPE() != null) return "integer";
        if (ctx.NUMBER_TYPE() != null) return "number";
        if (ctx.STRING_TYPE() != null) return "string";
        if (ctx.BOOLEAN_TYPE() != null) return "boolean";
        if (ctx.CHAR_TYPE() != null) return "char";
        if (ctx.ID() != null) return ctx.ID().getText();
        if (ctx.type() != null && ctx.LBRACK() != null && ctx.RBRACK() != null) {
            // Corrected: ANTLR generates type() for recursive rule, not type(0)
            return getTypeString(ctx.type()) + "[]";
        }
        throw new RuntimeException("Unknown type: " + ctx.getText());
    }


    private String getExpressionType(Object ctxNode) {
        if (ctxNode instanceof gemParser.ExpressionContext ctx) {
            return getLogicalExpressionType(ctx.logicalExpression());
        } else if (ctxNode instanceof gemParser.AdditiveExpressionContext ctx) {
            return getAdditiveExpressionType(ctx);
        }
        return semanticAnalyzer.getVariableType(((gemParser.PrimaryExpressionContext) ctxNode).ID().getText());
    }


    private String getLogicalExpressionType(gemParser.LogicalExpressionContext ctx) {
        if (ctx.comparisonExpression().size() > 1 || !ctx.AND().isEmpty() || !ctx.OR().isEmpty()) {
            return "boolean";
        }
        return getComparisonExpressionType(ctx.comparisonExpression(0));
    }

    private String getComparisonExpressionType(gemParser.ComparisonExpressionContext ctx) {
        if (ctx.additiveExpression().size() > 1) {
            return "boolean";
        }
        return getAdditiveExpressionType(ctx.additiveExpression(0));
    }

    private String getAdditiveExpressionType(gemParser.AdditiveExpressionContext ctx) {
        String type = getMultiplicativeExpressionType(ctx.multiplicativeExpression(0));
        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            String rightType = getMultiplicativeExpressionType(ctx.multiplicativeExpression(i));
            if (type.equals("string") || rightType.equals("string")) return "string";
            if (type.equals("number") || rightType.equals("number")) type = "number";
        }
        return type;
    }

    private String getMultiplicativeExpressionType(gemParser.MultiplicativeExpressionContext ctx) {
        String type = getMessageExpressionType(ctx.messageExpression(0));
        for (int i = 1; i < ctx.messageExpression().size(); i++) {
            String rightType = getMessageExpressionType(ctx.messageExpression(i));
            if (type.equals("number") || rightType.equals("number")) type = "number";
        }
        return type;
    }

    private String getMessageExpressionType(gemParser.MessageExpressionContext ctx) {
        if (ctx.LBRACK() != null) {
            // Array access - return element type
            String arrayType = getMessageExpressionType(ctx.messageExpression());
            if (arrayType != null && arrayType.endsWith("[]")) {
                return arrayType.substring(0, arrayType.length() - 2); // Remove [] to get element type
            }
            return arrayType; // Fallback
        } else if (ctx.ARROW() != null) {
            // This is a message passing expression
            String objType = getMessageExpressionType(ctx.messageExpression());
            String methodName = ctx.ID().getText();
            
            // Find the method in the target class
            Map<String, FunctionInfo> methodMap = typeMethods.getOrDefault(objType, Collections.emptyMap());
            FunctionInfo methodInfo = methodMap.get(methodName);
            
            if (methodInfo != null) {
                return methodInfo.returnType;
            }
        } else if (ctx.DOT() != null) {
            String objType = getMessageExpressionType(ctx.messageExpression());
            String memberName = ctx.ID().getText();
            
            if (ctx.LPAREN() != null) {
                // Method call
                Map<String, FunctionInfo> methodMap = typeMethods.getOrDefault(objType, Collections.emptyMap());
                FunctionInfo methodInfo = methodMap.get(memberName);
                if (methodInfo != null) {
                    return methodInfo.returnType;
                }
            } else {
                // Field access
                Map<String, String> fields = typeFields.getOrDefault(objType, Collections.emptyMap());
                if (fields.containsKey(memberName)) {
                    return fields.get(memberName);
                }
            }
        }
        
        // Default to the primary expression type if we can't determine a more specific type
        if (ctx.primaryExpression() != null) {
            return getPrimaryExpressionType(ctx.primaryExpression());
        }
        return null;
    }

    private String getPrimaryExpressionType(gemParser.PrimaryExpressionContext ctx) {
        if (ctx.ID() != null && ctx.LPAREN() == null) {
            return definedVariables.getOrDefault(ctx.ID().getText(), "unknown");
        } else if (ctx.literal() != null) {
            return getLiteralType(ctx.literal());
        } else if (ctx.expression() != null) {
            return getExpressionType(ctx.expression());
        } else if (ctx.ID() != null && ctx.LPAREN() != null) {
            String funcName = ctx.ID().getText();
            if (funcName.equals("read_integer") || funcName.equals("length")) return "integer";
            if (funcName.equals("read_line") || funcName.equals("uppercase")) return "string";
            if (funcName.equals("split")) return "string[]";
            FunctionInfo funcInfo = functions.get(funcName); // Check static functions first
            if (funcInfo != null) return funcInfo.returnType;
            // Could be a method call if part of a message expr; that's handled in getMessageExpressionType
            return "unknown"; // Fallback
        }
        return "unknown";
    }
    private String getFunctionCallReturnType(gemParser.FunctionCallContext ctx) {
        String funcName = ctx.ID(0).getText();
        if (ctx.ID().size() == 1) { // Simple function call
            if (funcName.equals("read_integer") || funcName.equals("length")) return "integer";
            if (funcName.equals("read_line") || funcName.equals("uppercase")) return "string";
            if (funcName.equals("split")) return "string[]";
            FunctionInfo funcInfo = functions.get(funcName);
            if (funcInfo != null) return funcInfo.returnType;
        } else { // Method call obj.method() or obj->method()
            String objName = ctx.ID(0).getText();
            String methodName = ctx.ID(1).getText();
            String objType = definedVariables.get(objName);
            if (objType != null && typeMethods.containsKey(objType)) {
                FunctionInfo methodInfo = typeMethods.get(objType).get(methodName);
                if (methodInfo != null) return methodInfo.returnType;
            }
        }
        return "void"; // Default or unknown
    }


    private String getLiteralType(gemParser.LiteralContext ctx) {
        if (ctx.INTEGER_LITERAL() != null) return "integer";
        if (ctx.FLOAT_LITERAL() != null) return "number";
        if (ctx.STRING_LITERAL() != null) return "string";
        if (ctx.CHAR_LITERAL() != null) return "char";
        if (ctx.BOOLEAN_LITERAL() != null) return "boolean";
        if (ctx.arrayLiteral() != null) {
            if (ctx.arrayLiteral().expression().isEmpty()) return "object[]";
            return getExpressionType(ctx.arrayLiteral().expression(0)) + "[]";
        }
        return "unknown";
    }

    private void generateIntegerInputWithErrorHandling(MethodVisitor mv) {
        Label loopStart = new Label();
        Label tryBlockStart = new Label();
        Label tryBlockEnd = new Label();
        Label catchBlockStart = new Label();
        Label loopEnd = new Label();

        mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
        mv.visitInsn(Opcodes.DUP);
        mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "in", "Ljava/io/InputStream;");
        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/util/Scanner", "<init>", "(Ljava/io/InputStream;)V", false);
        int scannerVar = nextVarIndex++; // Assuming nextVarIndex is managed correctly for local var allocation
        mv.visitVarInsn(Opcodes.ASTORE, scannerVar);

        mv.visitLabel(loopStart);
        mv.visitTryCatchBlock(tryBlockStart, tryBlockEnd, catchBlockStart, "java/util/InputMismatchException");

        mv.visitLabel(tryBlockStart);
        mv.visitVarInsn(Opcodes.ALOAD, scannerVar);
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/util/Scanner", "nextInt", "()I", false);
        mv.visitJumpInsn(Opcodes.GOTO, loopEnd);
        mv.visitLabel(tryBlockEnd);

        mv.visitLabel(catchBlockStart);
        int exceptionVar = nextVarIndex++;
        mv.visitVarInsn(Opcodes.ASTORE, exceptionVar);

        mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
        mv.visitLdcInsn("Invalid input. Please enter a valid integer.");
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);

        mv.visitVarInsn(Opcodes.ALOAD, scannerVar);
        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/util/Scanner", "next", "()Ljava/lang/String;", false);
        mv.visitInsn(Opcodes.POP);

        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        mv.visitLabel(loopEnd);
        // The integer read is on the stack
    }
}