import org.antlr.v4.runtime.tree.ParseTree;
import org.objectweb.asm.*;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.*;

public class CodeGenerator {
    private GemSemanticAnalyzer semanticAnalyzer;
    private Map<String, Integer> localVars = new HashMap<>();
    private Map<String, String> definedVariables = new HashMap<>();
    private int nextVarIndex = 1;
    private Label currentBreakLabel = null;
    private ClassWriter mainClassWriter;
    private String currentClassName;

    // For struct/class definitions
    private Map<String, ClassWriter> typeWriters = new HashMap<>();
    private Map<String, Map<String, String>> typeFields = new HashMap<>();
    private Map<String, Map<String, FunctionInfo>> typeMethods = new HashMap<>();

    // For function definitions
    private Map<String, FunctionInfo> functions = new HashMap<>();

    private static class FunctionInfo {
        String name;
        String descriptor;
        String returnType;
        List<String> paramTypes;
        List<String> paramNames;
        List<Boolean> paramRefs;
        ParseTree body;

        FunctionInfo(String name, String returnType) {
            this.name = name;
            this.returnType = returnType;
            this.paramTypes = new ArrayList<>();
            this.paramNames = new ArrayList<>();
            this.paramRefs = new ArrayList<>();
        }
    }

    public CodeGenerator() {
        this.definedVariables = new HashMap<>();
    }

    public void generate(ParseTree tree, GemSemanticAnalyzer analyzer, String className, String outputFile) {
        this.semanticAnalyzer = analyzer;
        this.currentClassName = className;

        for (Map.Entry<String, String> entry : analyzer.getAllVariableTypes().entrySet()) {
            definedVariables.put(entry.getKey(), entry.getValue());
        }

        try {
            mainClassWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

            mainClassWriter.visit(
                    Opcodes.V17,
                    Opcodes.ACC_PUBLIC,
                    className,
                    null,
                    "java/lang/Object",
                    null
            );

            // First pass: collect all type and function declarations
            collectDeclarations((gemParser.ProgramContext)tree);

            // Second pass: generate type classes
            generateTypeClasses();

            // Third pass: generate functions
            generateFunctions();

            // Generate main constructor
            MethodVisitor constructor = mainClassWriter.visitMethod(
                    Opcodes.ACC_PUBLIC,
                    "<init>",
                    "()V",
                    null,
                    null
            );
            constructor.visitCode();
            constructor.visitVarInsn(Opcodes.ALOAD, 0);
            constructor.visitMethodInsn(
                    Opcodes.INVOKESPECIAL,
                    "java/lang/Object",
                    "<init>",
                    "()V",
                    false
            );
            constructor.visitInsn(Opcodes.RETURN);
            constructor.visitMaxs(1, 1);
            constructor.visitEnd();

            // Generate main method
            MethodVisitor mv = mainClassWriter.visitMethod(
                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
                    "main",
                    "([Ljava/lang/String;)V",
                    null,
                    null
            );
            mv.visitCode();
            localVars.clear();
            nextVarIndex = 1;
            localVars.put("args", 0);

            generateProgram((gemParser.ProgramContext)tree, mv);

            mv.visitInsn(Opcodes.RETURN);
            mv.visitMaxs(0, 0);
            mv.visitEnd();

            mainClassWriter.visitEnd();

            // Write main class
            try (FileOutputStream fos = new FileOutputStream(outputFile)) {
                fos.write(mainClassWriter.toByteArray());
            }

            // Write type classes
            for (Map.Entry<String, ClassWriter> entry : typeWriters.entrySet()) {
                String typeName = entry.getKey();
                ClassWriter cw = entry.getValue();
                cw.visitEnd();

                try (FileOutputStream fos = new FileOutputStream(typeName + ".class")) {
                    fos.write(cw.toByteArray());
                }
            }

            System.out.println("Successfully generated bytecode: " + outputFile);
        } catch (IOException e) {
            System.err.println("Error generating bytecode: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void collectDeclarations(gemParser.ProgramContext ctx) {
        // Collect type declarations
        for (gemParser.DeclarationContext decl : ctx.declaration()) {
            if (decl.structDeclaration() != null) {
                collectStructDeclaration(decl.structDeclaration());
            } else if (decl.classDeclaration() != null) {
                collectClassDeclaration(decl.classDeclaration());
            } else if (decl.functionDeclaration() != null) {
                collectFunctionDeclaration(decl.functionDeclaration());
            }
        }
    }

    private void collectStructDeclaration(gemParser.StructDeclarationContext ctx) {
        String structName = ctx.ID(0).getText();
        Map<String, String> fields = new LinkedHashMap<>();

        for (gemParser.FieldContext field : ctx.field()) {
            String fieldType = getTypeString(field.type());
            String fieldName = field.ID().getText();
            fields.put(fieldName, fieldType);
        }

        typeFields.put(structName, fields);
    }

    private void collectClassDeclaration(gemParser.ClassDeclarationContext ctx) {
        String className = ctx.ID(0).getText();
        Map<String, String> fields = new LinkedHashMap<>();
        Map<String, FunctionInfo> methods = new HashMap<>();

        for (gemParser.FieldContext field : ctx.field()) {
            String fieldType = getTypeString(field.type());
            String fieldName = field.ID().getText();
            fields.put(fieldName, fieldType);
        }

        for (gemParser.FunctionDeclarationContext func : ctx.functionDeclaration()) {
            FunctionInfo info = collectFunctionInfo(func);
            methods.put(info.name, info);
        }

        typeFields.put(className, fields);
        typeMethods.put(className, methods);
    }

    private void collectFunctionDeclaration(gemParser.FunctionDeclarationContext ctx) {
        FunctionInfo info = collectFunctionInfo(ctx);
        functions.put(info.name, info);
    }

    private FunctionInfo collectFunctionInfo(gemParser.FunctionDeclarationContext ctx) {
        String funcName = ctx.ID().getText();
        String returnType = ctx.type() != null ? getTypeString(ctx.type()) : "void";

        FunctionInfo info = new FunctionInfo(funcName, returnType);
        info.body = ctx;

        if (ctx.parameterList() != null) {
            for (gemParser.ParameterContext param : ctx.parameterList().parameter()) {
                String paramType = getTypeString(param.type());
                String paramName = param.ID().getText();
                boolean isRef = param.REF() != null;
                info.paramTypes.add(paramType);
                info.paramNames.add(paramName);
                info.paramRefs.add(isRef);
            }
        }

        // Build descriptor
        StringBuilder desc = new StringBuilder("(");
        for (int i = 0; i < info.paramTypes.size(); i++) {
            if (info.paramRefs.get(i)) {
                desc.append("[");
            }
            desc.append(getTypeDescriptor(info.paramTypes.get(i)));
        }
        desc.append(")");
        desc.append(getTypeDescriptor(returnType));
        info.descriptor = desc.toString();

        return info;
    }

    private void generateTypeClasses() {
        for (Map.Entry<String, Map<String, String>> entry : typeFields.entrySet()) {
            String typeName = entry.getKey();
            Map<String, String> fields = entry.getValue();

            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
            cw.visit(
                    Opcodes.V17,
                    Opcodes.ACC_PUBLIC,
                    typeName,
                    null,
                    "java/lang/Object",
                    null
            );

            // Generate fields
            for (Map.Entry<String, String> field : fields.entrySet()) {
                FieldVisitor fv = cw.visitField(
                        Opcodes.ACC_PUBLIC,
                        field.getKey(),
                        getTypeDescriptor(field.getValue()),
                        null,
                        null
                );
                fv.visitEnd();
            }

            // Generate constructor
            MethodVisitor constructor = cw.visitMethod(
                    Opcodes.ACC_PUBLIC,
                    "<init>",
                    "()V",
                    null,
                    null
            );
            constructor.visitCode();
            constructor.visitVarInsn(Opcodes.ALOAD, 0);
            constructor.visitMethodInsn(
                    Opcodes.INVOKESPECIAL,
                    "java/lang/Object",
                    "<init>",
                    "()V",
                    false
            );

            // Initialize fields with default values
            for (Map.Entry<String, String> field : fields.entrySet()) {
                String fieldType = field.getValue();
                constructor.visitVarInsn(Opcodes.ALOAD, 0);

                if (fieldType.equals("integer") || fieldType.equals("boolean")) {
                    constructor.visitInsn(Opcodes.ICONST_0);
                    constructor.visitFieldInsn(Opcodes.PUTFIELD, typeName, field.getKey(), "I");
                } else if (fieldType.equals("number")) {
                    constructor.visitInsn(Opcodes.FCONST_0);
                    constructor.visitFieldInsn(Opcodes.PUTFIELD, typeName, field.getKey(), "F");
                } else {
                    constructor.visitInsn(Opcodes.ACONST_NULL);
                    constructor.visitFieldInsn(Opcodes.PUTFIELD, typeName, field.getKey(),
                            getTypeDescriptor(fieldType));
                }
            }

            constructor.visitInsn(Opcodes.RETURN);
            constructor.visitMaxs(0, 0);
            constructor.visitEnd();

            // Generate methods for classes
            Map<String, FunctionInfo> methods = typeMethods.get(typeName);
            if (methods != null) {
                for (FunctionInfo method : methods.values()) {
                    generateMethod(cw, typeName, method);
                }
            }

            typeWriters.put(typeName, cw);
        }
    }

    private void generateFunctions() {
        for (FunctionInfo func : functions.values()) {
            generateStaticMethod(mainClassWriter, func);
        }
    }

    private void generateMethod(ClassWriter cw, String className, FunctionInfo func) {
        MethodVisitor mv = cw.visitMethod(
                Opcodes.ACC_PUBLIC,
                func.name,
                func.descriptor,
                null,
                null
        );
        mv.visitCode();

        // Set up local variables
        Map<String, Integer> savedVars = new HashMap<>(localVars);
        int savedNextVar = nextVarIndex;

        localVars.clear();
        nextVarIndex = 0;
        localVars.put("this", nextVarIndex++);

        for (int i = 0; i < func.paramNames.size(); i++) {
            localVars.put(func.paramNames.get(i), nextVarIndex++);
            if (func.paramRefs.get(i)) {
                nextVarIndex++; // Arrays take 2 slots
            }
        }

        // Generate method body
        gemParser.FunctionDeclarationContext ctx = (gemParser.FunctionDeclarationContext) func.body;
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        // Default return
        if (func.returnType.equals("void")) {
            mv.visitInsn(Opcodes.RETURN);
        } else {
            // Return default value if no explicit return
            generateDefaultValue(func.returnType, mv);
            mv.visitInsn(getReturnOpcode(func.returnType));
        }

        mv.visitMaxs(0, 0);
        mv.visitEnd();

        localVars = savedVars;
        nextVarIndex = savedNextVar;
    }

    private void generateStaticMethod(ClassWriter cw, FunctionInfo func) {
        MethodVisitor mv = cw.visitMethod(
                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
                func.name,
                func.descriptor,
                null,
                null
        );
        mv.visitCode();

        // Set up local variables
        Map<String, Integer> savedVars = new HashMap<>(localVars);
        int savedNextVar = nextVarIndex;

        localVars.clear();
        nextVarIndex = 0;

        for (int i = 0; i < func.paramNames.size(); i++) {
            localVars.put(func.paramNames.get(i), nextVarIndex++);
            if (func.paramRefs.get(i)) {
                nextVarIndex++; // Arrays take 2 slots
            }
        }

        // Generate method body
        gemParser.FunctionDeclarationContext ctx = (gemParser.FunctionDeclarationContext) func.body;
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        // Default return
        if (func.returnType.equals("void")) {
            mv.visitInsn(Opcodes.RETURN);
        } else {
            // Return default value if no explicit return
            generateDefaultValue(func.returnType, mv);
            mv.visitInsn(getReturnOpcode(func.returnType));
        }

        mv.visitMaxs(0, 0);
        mv.visitEnd();

        localVars = savedVars;
        nextVarIndex = savedNextVar;
    }

    private void generateProgram(gemParser.ProgramContext ctx, MethodVisitor mv) {
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }
    }

    private void generateStatement(gemParser.StatementContext ctx, MethodVisitor mv) {
        if (ctx.variableDeclaration() != null) {
            generateVariableDeclaration(ctx.variableDeclaration(), mv);
        } else if (ctx.assignment() != null) {
            generateAssignment(ctx.assignment(), mv);
        } else if (ctx.ifStatement() != null) {
            generateIfStatement(ctx.ifStatement(), mv);
        } else if (ctx.forLoop() != null) {
            generateForLoop(ctx.forLoop(), mv);
        } else if (ctx.whileLoop() != null) {
            generateWhileLoop(ctx.whileLoop(), mv);
        } else if (ctx.loop() != null) {
            generateLoop(ctx.loop(), mv);
        } else if (ctx.printStatement() != null) {
            generatePrintStatement(ctx.printStatement(), mv);
        } else if (ctx.readStatement() != null) {
            generateReadStatement(ctx.readStatement(), mv);
        } else if (ctx.expression() != null) {
            generateExpression(ctx.expression(), mv);
            mv.visitInsn(Opcodes.POP);
        } else if (ctx.functionCall() != null) {
            generateFunctionCall(ctx.functionCall(), mv);
            mv.visitInsn(Opcodes.POP); // Discard return value
        } else if (ctx.returnStatement() != null) {
            generateReturnStatement(ctx.returnStatement(), mv);
        } else if (ctx.breakStatement() != null) {
            generateBreakStatement(ctx.breakStatement(), mv);
        } else if (ctx.innerFunctionDeclaration() != null) {
            // Inner functions not supported in this implementation
            throw new UnsupportedOperationException("Inner functions not supported");
        } else {
            throw new UnsupportedOperationException("Unsupported statement type");
        }
    }

    private void generateVariableDeclaration(gemParser.VariableDeclarationContext ctx, MethodVisitor mv) {
        String varName = ctx.ID().getText();
        String typeName;

        if (ctx.type() != null) {
            typeName = getTypeString(ctx.type());
        } else if (ctx.struct_type() != null) {
            typeName = ctx.struct_type().ID().getText();
        } else {
            typeName = ctx.class_type().ID().getText();
        }

        int varIndex = nextVarIndex++;
        localVars.put(varName, varIndex);
        definedVariables.put(varName, typeName);

        if (ctx.expression() != null) {
            generateExpression(ctx.expression(), mv);
            storeVariable(varName, typeName, mv);
        } else if (typeFields.containsKey(typeName)) {
            // Create new instance of struct/class
            mv.visitTypeInsn(Opcodes.NEW, typeName);
            mv.visitInsn(Opcodes.DUP);
            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, typeName, "<init>", "()V", false);
            mv.visitVarInsn(Opcodes.ASTORE, varIndex);
        } else {
            // Default value
            generateDefaultValue(typeName, mv);
            storeVariable(varName, typeName, mv);
        }
    }

    private void generateAssignment(gemParser.AssignmentContext ctx, MethodVisitor mv) {
        if (ctx.ID().size() > 1) {
            // Field assignment
            String objName = ctx.ID(0).getText();
            String fieldName = ctx.ID(1).getText();
            String objType = definedVariables.get(objName);

            loadVariable(objName, objType, mv);
            generateExpression(ctx.expression(0), mv);

            Map<String, String> fields = typeFields.get(objType);
            String fieldType = fields.get(fieldName);

            mv.visitFieldInsn(Opcodes.PUTFIELD, objType, fieldName, getTypeDescriptor(fieldType));
        } else if (ctx.LBRACK() != null) {
            // Array assignment
            String arrayName = ctx.ID(0).getText();
            loadVariable(arrayName, definedVariables.get(arrayName), mv);
            generateExpression(ctx.expression(0), mv); // index
            generateExpression(ctx.expression(1), mv); // value

            String elementType = definedVariables.get(arrayName).replace("[]", "");
            mv.visitInsn(getArrayStoreOpcode(elementType));
        } else {
            // Simple assignment
            String varName = ctx.ID(0).getText();
            String typeName = definedVariables.get(varName);
            generateExpression(ctx.expression(0), mv);
            storeVariable(varName, typeName, mv);
        }
    }

    private void generateIfStatement(gemParser.IfStatementContext ctx, MethodVisitor mv) {
        if (ctx.THEN() != null) {
            // Single-line if
            Label endLabel = new Label();

            generateExpression(ctx.expression(0), mv);
            mv.visitJumpInsn(Opcodes.IFEQ, endLabel);

            generateStatement(ctx.statement(0), mv);

            if (ctx.ELSE() != null && ctx.statement().size() > 1) {
                Label afterElseLabel = new Label();
                mv.visitJumpInsn(Opcodes.GOTO, afterElseLabel);
                mv.visitLabel(endLabel);
                generateStatement(ctx.statement(1), mv);
                mv.visitLabel(afterElseLabel);
            } else {
                mv.visitLabel(endLabel);
            }
        } else {
            // Multi-line if
            Label endLabel = new Label();
            List<Label> falseLabels = new ArrayList<>();

            for (int i = 0; i < ctx.expression().size(); i++) {
                Label falseLabel = new Label();
                falseLabels.add(falseLabel);

                generateExpression(ctx.expression(i), mv);
                mv.visitJumpInsn(Opcodes.IFEQ, falseLabel);

                // Find statements for this branch
                int startStmt = 0;
                for (int j = 0; j < i; j++) {
                    // Count statements in previous branches
                    startStmt += countStatementsInBranch(ctx, j);
                }
                int endStmt = startStmt + countStatementsInBranch(ctx, i);

                for (int j = startStmt; j < endStmt && j < ctx.statement().size(); j++) {
                    generateStatement(ctx.statement(j), mv);
                }

                mv.visitJumpInsn(Opcodes.GOTO, endLabel);
                mv.visitLabel(falseLabel);
            }

            // else branch
            if (ctx.ELSE() != null && hasElseBranch(ctx)) {
                int elseStart = 0;
                for (int i = 0; i < ctx.expression().size(); i++) {
                    elseStart += countStatementsInBranch(ctx, i);
                }

                for (int j = elseStart; j < ctx.statement().size(); j++) {
                    generateStatement(ctx.statement(j), mv);
                }
            }

            mv.visitLabel(endLabel);
        }
    }

    private int countStatementsInBranch(gemParser.IfStatementContext ctx, int branchIndex) {
        // This is a simplified implementation
        // In a real implementation, you'd need to parse the tree more carefully
        return 1; // Assume 1 statement per branch for now
    }

    private boolean hasElseBranch(gemParser.IfStatementContext ctx) {
        // Check if there's an else without an if after it
        for (int i = 0; i < ctx.getChildCount() - 1; i++) {
            if (ctx.getChild(i).getText().equals("else") &&
                    !ctx.getChild(i + 1).getText().equals("if")) {
                return true;
            }
        }
        return false;
    }

    private void generateForLoop(gemParser.ForLoopContext ctx, MethodVisitor mv) {
        String loopVar = ctx.ID().getText();
        int varIndex = nextVarIndex++;
        localVars.put(loopVar, varIndex);
        definedVariables.put(loopVar, "integer");

        Label loopStart = new Label();
        Label loopEnd = new Label();
        Label prevBreakLabel = currentBreakLabel;
        currentBreakLabel = loopEnd;

        // Initialize loop variable
        generateExpression(ctx.expression(0), mv);
        mv.visitVarInsn(Opcodes.ISTORE, varIndex);

        mv.visitLabel(loopStart);

        // Check condition
        mv.visitVarInsn(Opcodes.ILOAD, varIndex);
        generateExpression(ctx.expression(1), mv);
        mv.visitJumpInsn(Opcodes.IF_ICMPGT, loopEnd);

        // Execute body
        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        // Increment
        mv.visitIincInsn(varIndex, 1);
        mv.visitJumpInsn(Opcodes.GOTO, loopStart);

        mv.visitLabel(loopEnd);
        currentBreakLabel = prevBreakLabel;

        // Remove loop variable from scope
        localVars.remove(loopVar);
        definedVariables.remove(loopVar);
    }

    private void generateWhileLoop(gemParser.WhileLoopContext ctx, MethodVisitor mv) {
        Label loopStart = new Label();
        Label loopEnd = new Label();
        Label prevBreakLabel = currentBreakLabel;
        currentBreakLabel = loopEnd;

        mv.visitLabel(loopStart);
        generateExpression(ctx.expression(), mv);
        mv.visitJumpInsn(Opcodes.IFEQ, loopEnd);

        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        mv.visitJumpInsn(Opcodes.GOTO, loopStart);
        mv.visitLabel(loopEnd);
        currentBreakLabel = prevBreakLabel;
    }

    private void generateLoop(gemParser.LoopContext ctx, MethodVisitor mv) {
        Label loopStart = new Label();
        Label loopEnd = new Label();
        Label prevBreakLabel = currentBreakLabel;
        currentBreakLabel = loopEnd;

        mv.visitLabel(loopStart);

        for (gemParser.StatementContext stmt : ctx.statement()) {
            generateStatement(stmt, mv);
        }

        mv.visitJumpInsn(Opcodes.GOTO, loopStart);
        mv.visitLabel(loopEnd);
        currentBreakLabel = prevBreakLabel;
    }

    private void generateBreakStatement(gemParser.BreakStatementContext ctx, MethodVisitor mv) {
        if (currentBreakLabel == null) {
            throw new UnsupportedOperationException("Break statement not in a loop");
        }
        mv.visitJumpInsn(Opcodes.GOTO, currentBreakLabel);
    }

    private void generateReturnStatement(gemParser.ReturnStatementContext ctx, MethodVisitor mv) {
        generateExpression(ctx.expression(), mv);
        // The correct return opcode will be determined by the expression type
        String exprType = getExpressionType(ctx.expression());
        mv.visitInsn(getReturnOpcode(exprType));
    }

    private void generatePrintStatement(gemParser.PrintStatementContext ctx, MethodVisitor mv) {
        mv.visitFieldInsn(
                Opcodes.GETSTATIC,
                "java/lang/System",
                "out",
                "Ljava/io/PrintStream;"
        );

        String exprType = getExpressionType(ctx.expression());

        if (isConcatenation(ctx.expression())) {
            generateStringConcatenation(ctx.expression(), mv);
        } else {
            generateExpression(ctx.expression(), mv);

            if (!exprType.equals("string")) {
                switch(exprType) {
                    case "integer" -> mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            "java/lang/String",
                            "valueOf",
                            "(I)Ljava/lang/String;",
                            false
                    );
                    case "number" -> mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            "java/lang/String",
                            "valueOf",
                            "(F)Ljava/lang/String;",
                            false
                    );
                    case "boolean" -> {
                        // Convert boolean to "true"/"false" string
                        Label trueLabel = new Label();
                        Label endLabel = new Label();
                        mv.visitJumpInsn(Opcodes.IFNE, trueLabel);
                        mv.visitLdcInsn("false");
                        mv.visitJumpInsn(Opcodes.GOTO, endLabel);
                        mv.visitLabel(trueLabel);
                        mv.visitLdcInsn("true");
                        mv.visitLabel(endLabel);
                    }
                    default -> mv.visitMethodInsn(
                            Opcodes.INVOKESTATIC,
                            "java/lang/String",
                            "valueOf",
                            "(Ljava/lang/Object;)Ljava/lang/String;",
                            false
                    );
                }
            }
        }

        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/io/PrintStream",
                "println",
                "(Ljava/lang/String;)V",
                false
        );
    }

    private boolean isConcatenation(gemParser.ExpressionContext ctx) {
        gemParser.ComparisonExpressionContext compCtx = ctx.logicalExpression().comparisonExpression(0);
        gemParser.AdditiveExpressionContext addCtx = compCtx.additiveExpression(0);
        return addCtx.multiplicativeExpression().size() > 1 && addCtx.PLUS().size() > 0;
    }

    private void generateStringConcatenation(gemParser.ExpressionContext ctx, MethodVisitor mv) {
        mv.visitTypeInsn(Opcodes.NEW, "java/lang/StringBuilder");
        mv.visitInsn(Opcodes.DUP);
        mv.visitMethodInsn(
                Opcodes.INVOKESPECIAL,
                "java/lang/StringBuilder",
                "<init>",
                "()V",
                false
        );

        gemParser.ComparisonExpressionContext compCtx = ctx.logicalExpression().comparisonExpression(0);
        gemParser.AdditiveExpressionContext addCtx = compCtx.additiveExpression(0);

        for (int i = 0; i < addCtx.multiplicativeExpression().size(); i++) {
            String opType = getMultiplicativeExpressionType(addCtx.multiplicativeExpression(i));
            generateMultiplicativeExpression(addCtx.multiplicativeExpression(i), mv);
            appendToStringBuilder(mv, opType);
        }

        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/StringBuilder",
                "toString",
                "()Ljava/lang/String;",
                false
        );
    }

    private void appendToStringBuilder(MethodVisitor mv, String type) {
        String descriptor;
        switch (type) {
            case "integer" -> descriptor = "(I)Ljava/lang/StringBuilder;";
            case "number" -> descriptor = "(F)Ljava/lang/StringBuilder;";
            case "boolean" -> descriptor = "(Z)Ljava/lang/StringBuilder;";
            case "string" -> descriptor = "(Ljava/lang/String;)Ljava/lang/StringBuilder;";
            default -> descriptor = "(Ljava/lang/Object;)Ljava/lang/StringBuilder;";
        }

        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/lang/StringBuilder",
                "append",
                descriptor,
                false
        );
    }

    private void generateReadStatement(gemParser.ReadStatementContext ctx, MethodVisitor mv) {
        String funcName = ctx.ID().getText();

        if (funcName.equals("read_integer")) {
            generateIntegerInputWithErrorHandling(mv);
        } else if (funcName.equals("read_line")) {
            mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
            mv.visitInsn(Opcodes.DUP);
            mv.visitFieldInsn(
                    Opcodes.GETSTATIC,
                    "java/lang/System",
                    "in",
                    "Ljava/io/InputStream;"
            );
            mv.visitMethodInsn(
                    Opcodes.INVOKESPECIAL,
                    "java/util/Scanner",
                    "<init>",
                    "(Ljava/io/InputStream;)V",
                    false
            );
            mv.visitMethodInsn(
                    Opcodes.INVOKEVIRTUAL,
                    "java/util/Scanner",
                    "nextLine",
                    "()Ljava/lang/String;",
                    false
            );
        } else {
            throw new UnsupportedOperationException("Unsupported read function: " + funcName);
        }
    }

    private void generateExpression(gemParser.ExpressionContext ctx, MethodVisitor mv) {
        generateLogicalExpression(ctx.logicalExpression(), mv);
    }

    private void generateLogicalExpression(gemParser.LogicalExpressionContext ctx, MethodVisitor mv) {
        if (ctx.comparisonExpression().size() == 1) {
            generateComparisonExpression(ctx.comparisonExpression(0), mv);
            return;
        }

        generateComparisonExpression(ctx.comparisonExpression(0), mv);

        for (int i = 0; i < ctx.getChildCount() / 2; i++) {
            String operator = ctx.getChild(i * 2 + 1).getText();

            if (operator.equals("and")) {
                Label falseLabel = new Label();
                Label endLabel = new Label();

                mv.visitJumpInsn(Opcodes.IFEQ, falseLabel);
                generateComparisonExpression(ctx.comparisonExpression(i + 1), mv);
                mv.visitJumpInsn(Opcodes.GOTO, endLabel);

                mv.visitLabel(falseLabel);
                mv.visitInsn(Opcodes.ICONST_0);

                mv.visitLabel(endLabel);
            } else if (operator.equals("or")) {
                Label trueLabel = new Label();
                Label endLabel = new Label();

                mv.visitJumpInsn(Opcodes.IFNE, trueLabel);
                generateComparisonExpression(ctx.comparisonExpression(i + 1), mv);
                mv.visitJumpInsn(Opcodes.GOTO, endLabel);

                mv.visitLabel(trueLabel);
                mv.visitInsn(Opcodes.ICONST_1);

                mv.visitLabel(endLabel);
            }
        }
    }

    private void generateComparisonExpression(gemParser.ComparisonExpressionContext ctx, MethodVisitor mv) {
        if (ctx.additiveExpression().size() == 1) {
            generateAdditiveExpression(ctx.additiveExpression(0), mv);
            return;
        }

        String leftType = getExpressionType(ctx.additiveExpression(0));
        String rightType = getExpressionType(ctx.additiveExpression(1));

        generateAdditiveExpression(ctx.additiveExpression(0), mv);
        generateAdditiveExpression(ctx.additiveExpression(1), mv);

        String op = ctx.getChild(1).getText();
        Label trueLabel = new Label();
        Label endLabel = new Label();

        if ("string".equals(leftType) && "string".equals(rightType)) {
            if ("==".equals(op)) {
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "equals", "(Ljava/lang/Object;)Z", false);
                mv.visitJumpInsn(Opcodes.IFNE, trueLabel);
            } else if ("!=".equals(op)) {
                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/String", "equals", "(Ljava/lang/Object;)Z", false);
                mv.visitJumpInsn(Opcodes.IFEQ, trueLabel);
            } else {
                throw new UnsupportedOperationException("Unsupported string comparison operator: " + op);
            }
        } else {
            switch (op) {
                case "<" -> mv.visitJumpInsn(Opcodes.IF_ICMPLT, trueLabel);
                case ">" -> mv.visitJumpInsn(Opcodes.IF_ICMPGT, trueLabel);
                case "<=" -> mv.visitJumpInsn(Opcodes.IF_ICMPLE, trueLabel);
                case ">=" -> mv.visitJumpInsn(Opcodes.IF_ICMPGE, trueLabel);
                case "==" -> mv.visitJumpInsn(Opcodes.IF_ICMPEQ, trueLabel);
                case "!=" -> mv.visitJumpInsn(Opcodes.IF_ICMPNE, trueLabel);
                default -> throw new UnsupportedOperationException("Unsupported comparison operator: " + op);
            }
        }

        mv.visitInsn(Opcodes.ICONST_0);
        mv.visitJumpInsn(Opcodes.GOTO, endLabel);

        mv.visitLabel(trueLabel);
        mv.visitInsn(Opcodes.ICONST_1);

        mv.visitLabel(endLabel);
    }

    private void generateAdditiveExpression(gemParser.AdditiveExpressionContext ctx, MethodVisitor mv) {
        if (ctx.multiplicativeExpression().size() == 1) {
            generateMultiplicativeExpression(ctx.multiplicativeExpression(0), mv);
            return;
        }

        generateMultiplicativeExpression(ctx.multiplicativeExpression(0), mv);

        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            generateMultiplicativeExpression(ctx.multiplicativeExpression(i), mv);

            String op = ctx.getChild(i * 2 - 1).getText();
            if (op.equals("+")) {
                mv.visitInsn(Opcodes.IADD);
            } else if (op.equals("-")) {
                mv.visitInsn(Opcodes.ISUB);
            }
        }
    }

    private void generateMultiplicativeExpression(gemParser.MultiplicativeExpressionContext ctx, MethodVisitor mv) {
        generateMessageExpression(ctx.messageExpression(0), mv);

        for (int i = 1; i < ctx.messageExpression().size(); i++) {
            generateMessageExpression(ctx.messageExpression(i), mv);

            String op = ctx.getChild(i * 2 - 1).getText();
            switch (op) {
                case "*" -> mv.visitInsn(Opcodes.IMUL);
                case "/" -> mv.visitInsn(Opcodes.IDIV);
                case "%" -> mv.visitInsn(Opcodes.IREM);
                default -> throw new UnsupportedOperationException("Unsupported multiplicative operator: " + op);
            }
        }
    }

    private void generateMessageExpression(gemParser.MessageExpressionContext ctx, MethodVisitor mv) {
        if (ctx.ARROW() != null) {
            // Message passing
            generatePrimaryExpression(ctx.primaryExpression(), mv);
            String funcName = ctx.ID().getText();

            // For now, just treat as a method call
            if (ctx.argumentList() != null) {
                for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                    generateExpression(arg.expression(), mv);
                }
            }

            // Simplified - assume it returns the first argument
            // In a real implementation, you'd look up the message handler
        } else if (ctx.DOT() != null && ctx.LPAREN() != null) {
            // Method call
            generatePrimaryExpression(ctx.primaryExpression(), mv);
            String methodName = ctx.ID().getText();

            // Get object type
            String objType = getPrimaryExpressionType(ctx.primaryExpression());
            Map<String, FunctionInfo> methods = typeMethods.get(objType);

            if (methods != null && methods.containsKey(methodName)) {
                FunctionInfo method = methods.get(methodName);

                if (ctx.argumentList() != null) {
                    for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                        generateExpression(arg.expression(), mv);
                    }
                }

                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, objType, methodName,
                        method.descriptor, false);
            } else {
                throw new UnsupportedOperationException("Unknown method: " + methodName);
            }
        } else if (ctx.DOT() != null) {
            // Field access
            generatePrimaryExpression(ctx.primaryExpression(), mv);
            String fieldName = ctx.ID().getText();

            String objType = getPrimaryExpressionType(ctx.primaryExpression());
            Map<String, String> fields = typeFields.get(objType);

            if (fields != null && fields.containsKey(fieldName)) {
                String fieldType = fields.get(fieldName);
                mv.visitFieldInsn(Opcodes.GETFIELD, objType, fieldName,
                        getTypeDescriptor(fieldType));
            } else {
                throw new UnsupportedOperationException("Unknown field: " + fieldName);
            }
        } else if (ctx.LBRACK() != null) {
            // Array access
            generatePrimaryExpression(ctx.primaryExpression(), mv);
            generateExpression(ctx.expression(), mv);

            String arrayType = getPrimaryExpressionType(ctx.primaryExpression());
            String elementType = arrayType.replace("[]", "");
            mv.visitInsn(getArrayLoadOpcode(elementType));
        } else {
            generatePrimaryExpression(ctx.primaryExpression(), mv);
        }
    }

    private void generatePrimaryExpression(gemParser.PrimaryExpressionContext ctx, MethodVisitor mv) {
        if (ctx.ID() != null && ctx.LPAREN() == null) {
            String varName = ctx.ID().getText();
            String varType = definedVariables.get(varName);
            loadVariable(varName, varType, mv);
        } else if (ctx.literal() != null) {
            generateLiteral(ctx.literal(), mv);
        } else if (ctx.expression() != null) {
            generateExpression(ctx.expression(), mv);
        } else if (ctx.ID() != null && ctx.LPAREN() != null) {
            generateFunctionCall(ctx, mv);
        }
    }

    private void generateFunctionCall(gemParser.PrimaryExpressionContext ctx, MethodVisitor mv) {
        String funcName = ctx.ID().getText();

        if (funcName.equals("read_integer")) {
            generateIntegerInputWithErrorHandling(mv);
        } else if (funcName.equals("read_line")) {
            mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
            mv.visitInsn(Opcodes.DUP);
            mv.visitFieldInsn(
                    Opcodes.GETSTATIC,
                    "java/lang/System",
                    "in",
                    "Ljava/io/InputStream;"
            );
            mv.visitMethodInsn(
                    Opcodes.INVOKESPECIAL,
                    "java/util/Scanner",
                    "<init>",
                    "(Ljava/io/InputStream;)V",
                    false
            );
            mv.visitMethodInsn(
                    Opcodes.INVOKEVIRTUAL,
                    "java/util/Scanner",
                    "nextLine",
                    "()Ljava/lang/String;",
                    false
            );
        } else if (funcName.equals("split")) {
            // Implement split function
            if (ctx.argumentList() != null && ctx.argumentList().argument().size() == 2) {
                generateExpression(ctx.argumentList().argument(0).expression(), mv);
                generateExpression(ctx.argumentList().argument(1).expression(), mv);
                mv.visitMethodInsn(
                        Opcodes.INVOKEVIRTUAL,
                        "java/lang/String",
                        "split",
                        "(Ljava/lang/String;)[Ljava/lang/String;",
                        false
                );
            }
        } else if (funcName.equals("length")) {
            if (ctx.argumentList() != null && ctx.argumentList().argument().size() == 1) {
                generateExpression(ctx.argumentList().argument(0).expression(), mv);
                String argType = getExpressionType(ctx.argumentList().argument(0).expression());

                if (argType.equals("string")) {
                    mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/lang/String",
                            "length",
                            "()I",
                            false
                    );
                } else if (argType.endsWith("[]")) {
                    mv.visitInsn(Opcodes.ARRAYLENGTH);
                }
            }
        } else if (funcName.equals("uppercase")) {
            if (ctx.argumentList() != null && ctx.argumentList().argument().size() == 1) {
                generateExpression(ctx.argumentList().argument(0).expression(), mv);
                mv.visitMethodInsn(
                        Opcodes.INVOKEVIRTUAL,
                        "java/lang/String",
                        "toUpperCase",
                        "()Ljava/lang/String;",
                        false
                );
            }
        } else if (functions.containsKey(funcName)) {
            // User-defined function
            FunctionInfo func = functions.get(funcName);

            if (ctx.argumentList() != null) {
                int argIndex = 0;
                for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                    if (argIndex < func.paramRefs.size() && func.paramRefs.get(argIndex)) {
                        // Reference parameter - wrap in array
                        mv.visitIntInsn(Opcodes.SIPUSH, 1);
                        String paramType = func.paramTypes.get(argIndex);
                        if (paramType.equals("string")) {
                            mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/String");
                        } else if (paramType.equals("integer") || paramType.equals("boolean")) {
                            mv.visitIntInsn(Opcodes.NEWARRAY, Opcodes.T_INT);
                        } else if (paramType.equals("number")) {
                            mv.visitIntInsn(Opcodes.NEWARRAY, Opcodes.T_FLOAT);
                        } else {
                            mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");
                        }
                        mv.visitInsn(Opcodes.DUP);
                        mv.visitInsn(Opcodes.ICONST_0);
                        generateExpression(arg.expression(), mv);
                        mv.visitInsn(getArrayStoreOpcode(func.paramTypes.get(argIndex)));
                    } else {
                        generateExpression(arg.expression(), mv);
                    }
            }

            mv.visitMethodInsn(Opcodes.INVOKESTATIC, currentClassName, funcName,
                    func.descriptor, false);
        } else {
            throw new UnsupportedOperationException("Unknown function: " + funcName);
        }
    }

    private void generateFunctionCall(gemParser.FunctionCallContext ctx, MethodVisitor mv) {
        if (ctx.ID().size() == 1) {
            // Simple function call
            String funcName = ctx.ID(0).getText();

            if (functions.containsKey(funcName)) {
                FunctionInfo func = functions.get(funcName);

                if (ctx.argumentList() != null) {
                    int argIndex = 0;
                    for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                        if (arg.REF() != null ||
                                (argIndex < func.paramRefs.size() && func.paramRefs.get(argIndex))) {
                            // Reference parameter
                            String varName = arg.expression().logicalExpression()
                                    .comparisonExpression(0).additiveExpression(0)
                                    .multiplicativeExpression(0).messageExpression(0)
                                    .primaryExpression().ID().getText();
                            String varType = definedVariables.get(varName);

                            mv.visitIntInsn(Opcodes.SIPUSH, 1);
                            mv.visitIntInsn(Opcodes.NEWARRAY, getArrayTypeOpcode(varType));
                            mv.visitInsn(Opcodes.DUP);
                            mv.visitInsn(Opcodes.ICONST_0);
                            loadVariable(varName, varType, mv);
                            mv.visitInsn(getArrayStoreOpcode(varType));

                            // Store back after call
                            mv.visitInsn(Opcodes.DUP);
                            mv.visitMethodInsn(Opcodes.INVOKESTATIC, currentClassName, funcName,
                                    func.descriptor, false);
                            mv.visitInsn(Opcodes.ICONST_0);
                            mv.visitInsn(getArrayLoadOpcode(varType));
                            storeVariable(varName, varType, mv);

                            return;
                        } else {
                            generateExpression(arg.expression(), mv);
                        }
                        argIndex++;
                    }
                }

                mv.visitMethodInsn(Opcodes.INVOKESTATIC, currentClassName, funcName,
                        func.descriptor, false);
            }
        } else {
            // Method call or message passing
            String objName = ctx.ID(0).getText();
            String methodName = ctx.ID(1).getText();

            loadVariable(objName, definedVariables.get(objName), mv);

            if (ctx.argumentList() != null) {
                for (gemParser.ArgumentContext arg : ctx.argumentList().argument()) {
                    generateExpression(arg.expression(), mv);
                }
            }

            // Simplified - just pop the arguments
            // In a real implementation, you'd look up the method signature
        }
    }

    private void generateLiteral(gemParser.LiteralContext ctx, MethodVisitor mv) {
        if (ctx.INTEGER_LITERAL() != null) {
            int value = Integer.parseInt(ctx.INTEGER_LITERAL().getText());
            switch (value) {
                case -1 -> mv.visitInsn(Opcodes.ICONST_M1);
                case 0 -> mv.visitInsn(Opcodes.ICONST_0);
                case 1 -> mv.visitInsn(Opcodes.ICONST_1);
                case 2 -> mv.visitInsn(Opcodes.ICONST_2);
                case 3 -> mv.visitInsn(Opcodes.ICONST_3);
                case 4 -> mv.visitInsn(Opcodes.ICONST_4);
                case 5 -> mv.visitInsn(Opcodes.ICONST_5);
                default -> {
                    if (value >= -128 && value <= 127) {
                        mv.visitIntInsn(Opcodes.BIPUSH, value);
                    } else if (value >= -32768 && value <= 32767) {
                        mv.visitIntInsn(Opcodes.SIPUSH, value);
                    } else {
                        mv.visitLdcInsn(value);
                    }
                }
            }
        } else if (ctx.FLOAT_LITERAL() != null) {
            float value = Float.parseFloat(ctx.FLOAT_LITERAL().getText());
            mv.visitLdcInsn(value);
        } else if (ctx.STRING_LITERAL() != null) {
            String value = ctx.STRING_LITERAL().getText();
            value = value.substring(1, value.length() - 1);
            mv.visitLdcInsn(value);
        } else if (ctx.BOOLEAN_LITERAL() != null) {
            String value = ctx.BOOLEAN_LITERAL().getText();
            if (value.equals("yes")) {
                mv.visitInsn(Opcodes.ICONST_1);
            } else {
                mv.visitInsn(Opcodes.ICONST_0);
            }
        } else if (ctx.arrayLiteral() != null) {
            generateArrayLiteral(ctx.arrayLiteral(), mv);
        }
    }

    private void generateArrayLiteral(gemParser.ArrayLiteralContext ctx, MethodVisitor mv) {
        int size = ctx.expression().size();
        mv.visitIntInsn(Opcodes.SIPUSH, size);

        if (size > 0) {
            String elementType = getExpressionType(ctx.expression(0));

            // Handle different array types correctly
            if (elementType.equals("string")) {
                mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/String");
            } else if (elementType.equals("integer") || elementType.equals("boolean")) {
                mv.visitIntInsn(Opcodes.NEWARRAY, Opcodes.T_INT);
            } else if (elementType.equals("number")) {
                mv.visitIntInsn(Opcodes.NEWARRAY, Opcodes.T_FLOAT);
            } else {
                // For other object types
                mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");
            }

            for (int i = 0; i < size; i++) {
                mv.visitInsn(Opcodes.DUP);
                mv.visitIntInsn(Opcodes.SIPUSH, i);
                generateExpression(ctx.expression(i), mv);
                mv.visitInsn(getArrayStoreOpcode(elementType));
            }
        } else {
            // Empty array - default to Object[]
            mv.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");
        }
    }

    private void loadVariable(String name, String type, MethodVisitor mv) {
        if (!localVars.containsKey(name)) {
            throw new RuntimeException("Variable not found: " + name);
        }

        int index = localVars.get(name);

        switch (type) {
            case "integer", "boolean" -> mv.visitVarInsn(Opcodes.ILOAD, index);
            case "number" -> mv.visitVarInsn(Opcodes.FLOAD, index);
            default -> mv.visitVarInsn(Opcodes.ALOAD, index);
        }
    }

    private void storeVariable(String name, String type, MethodVisitor mv) {
        if (!localVars.containsKey(name)) {
            throw new RuntimeException("Variable not found: " + name);
        }

        int index = localVars.get(name);

        switch (type) {
            case "integer", "boolean" -> mv.visitVarInsn(Opcodes.ISTORE, index);
            case "number" -> mv.visitVarInsn(Opcodes.FSTORE, index);
            default -> mv.visitVarInsn(Opcodes.ASTORE, index);
        }
    }

    private void generateDefaultValue(String type, MethodVisitor mv) {
        switch (type) {
            case "integer", "boolean" -> mv.visitInsn(Opcodes.ICONST_0);
            case "number" -> mv.visitInsn(Opcodes.FCONST_0);
            case "void" -> { /* no value */ }
            default -> mv.visitInsn(Opcodes.ACONST_NULL);
        }
    }

    private String getTypeDescriptor(String type) {
        return switch (type) {
            case "integer", "boolean" -> "I";
            case "number" -> "F";
            case "string" -> "Ljava/lang/String;";
            case "void" -> "V";
            default -> {
                if (type.endsWith("[]")) {
                    String elementType = type.replace("[]", "");
                    yield "[" + getTypeDescriptor(elementType);
                } else {
                    yield "L" + type + ";";
                }
            }
        };
    }

    private int getArrayTypeOpcode(String type) {
        return switch (type) {
            case "integer", "boolean" -> Opcodes.T_INT;
            case "number" -> Opcodes.T_FLOAT;
            default -> throw new UnsupportedOperationException("Array type: " + type);
        };
    }

    private int getArrayLoadOpcode(String type) {
        return switch (type) {
            case "integer", "boolean" -> Opcodes.IALOAD;
            case "number" -> Opcodes.FALOAD;
            default -> Opcodes.AALOAD;
        };
    }

    private int getArrayStoreOpcode(String type) {
        return switch (type) {
            case "integer", "boolean" -> Opcodes.IASTORE;
            case "number" -> Opcodes.FASTORE;
            default -> Opcodes.AASTORE;
        };
    }

    private int getReturnOpcode(String type) {
        return switch (type) {
            case "integer", "boolean" -> Opcodes.IRETURN;
            case "number" -> Opcodes.FRETURN;
            case "void" -> Opcodes.RETURN;
            default -> Opcodes.ARETURN;
        };
    }

    private String getTypeString(gemParser.TypeContext ctx) {
        if (ctx.INTEGER_TYPE() != null) return "integer";
        if (ctx.NUMBER_TYPE() != null) return "number";
        if (ctx.STRING_TYPE() != null) return "string";
        if (ctx.BOOLEAN_TYPE() != null) return "boolean";
        if (ctx.CHAR_TYPE() != null) return "char";

        if (ctx.type() != null && ctx.LBRACK() != null) {
            return getTypeString(ctx.type()) + "[]";
        }

        if (ctx.ID() != null) {
            return ctx.ID().getText();
        }

        return null;
    }

    private String getExpressionType(Object ctx) {
        if (ctx instanceof gemParser.ExpressionContext) {
            return getLogicalExpressionType(((gemParser.ExpressionContext) ctx).logicalExpression());
        } else if (ctx instanceof gemParser.AdditiveExpressionContext) {
            return getAdditiveExpressionType((gemParser.AdditiveExpressionContext) ctx);
        }
        return "unknown";
    }

    private String getLogicalExpressionType(gemParser.LogicalExpressionContext ctx) {
        if (ctx.comparisonExpression().size() > 1 ||
                (ctx.getChildCount() > 1 &&
                        (ctx.getChild(1).getText().equals("and") ||
                                ctx.getChild(1).getText().equals("or")))) {
            return "boolean";
        }
        return getComparisonExpressionType(ctx.comparisonExpression(0));
    }

    private String getComparisonExpressionType(gemParser.ComparisonExpressionContext ctx) {
        if (ctx.getChildCount() > 1) {
            return "boolean";
        }
        return getAdditiveExpressionType(ctx.additiveExpression(0));
    }

    private String getAdditiveExpressionType(gemParser.AdditiveExpressionContext ctx) {
        for (gemParser.MultiplicativeExpressionContext mexpr : ctx.multiplicativeExpression()) {
            if ("string".equals(getMultiplicativeExpressionType(mexpr))) {
                return "string";
            }
        }
        return getMultiplicativeExpressionType(ctx.multiplicativeExpression(0));
    }

    private String getMultiplicativeExpressionType(gemParser.MultiplicativeExpressionContext ctx) {
        if (ctx.messageExpression().size() == 1) {
            return getMessageExpressionType(ctx.messageExpression(0));
        }

        String leftType = getMessageExpressionType(ctx.messageExpression(0));
        for (int i = 1; i < ctx.messageExpression().size(); i++) {
            String rightType = getMessageExpressionType(ctx.messageExpression(i));

            if (leftType.equals("string") || rightType.equals("string")) {
                return "string";
            }

            if (leftType.equals("number") || rightType.equals("number")) {
                return "number";
            }
        }

        return leftType;
    }

    private String getMessageExpressionType(gemParser.MessageExpressionContext ctx) {
        if (ctx.primaryExpression() != null) {
            return getPrimaryExpressionType(ctx.primaryExpression());
        }
        return "unknown";
    }

    private String getPrimaryExpressionType(gemParser.PrimaryExpressionContext ctx) {
        if (ctx.ID() != null && ctx.LPAREN() == null) {
            String varName = ctx.ID().getText();
            return definedVariables.get(varName);
        } else if (ctx.literal() != null) {
            return getLiteralType(ctx.literal());
        } else if (ctx.expression() != null) {
            return getExpressionType(ctx.expression());
        } else if (ctx.ID() != null && ctx.LPAREN() != null) {
            String funcName = ctx.ID().getText();
            if (funcName.equals("read_integer") || funcName.equals("length")) return "integer";
            if (funcName.equals("read_line") || funcName.equals("uppercase")) return "string";
            if (funcName.equals("split")) return "string[]";
            if (functions.containsKey(funcName)) {
                return functions.get(funcName).returnType;
            }
            return "unknown";
        }
        return "unknown";
    }

    private String getLiteralType(gemParser.LiteralContext ctx) {
        if (ctx.INTEGER_LITERAL() != null) return "integer";
        if (ctx.FLOAT_LITERAL() != null) return "number";
        if (ctx.STRING_LITERAL() != null) return "string";
        if (ctx.CHAR_LITERAL() != null) return "char";
        if (ctx.BOOLEAN_LITERAL() != null) return "boolean";
        if (ctx.arrayLiteral() != null) {
            if (ctx.arrayLiteral().expression().size() > 0) {
                return getExpressionType(ctx.arrayLiteral().expression(0)) + "[]";
            }
            return "object[]";
        }
        return "unknown";
    }

    private void generateIntegerInputWithErrorHandling(MethodVisitor mv) {
        Label loopStart = new Label();
        Label loopEnd = new Label();
        Label tryStart = new Label();
        Label tryEnd = new Label();
        Label catchHandler = new Label();

        mv.visitTypeInsn(Opcodes.NEW, "java/util/Scanner");
        mv.visitInsn(Opcodes.DUP);
        mv.visitFieldInsn(
                Opcodes.GETSTATIC,
                "java/lang/System",
                "in",
                "Ljava/io/InputStream;"
        );
        mv.visitMethodInsn(
                Opcodes.INVOKESPECIAL,
                "java/util/Scanner",
                "<init>",
                "(Ljava/io/InputStream;)V",
                false
        );

        int scannerVarIndex = nextVarIndex++;
        mv.visitVarInsn(Opcodes.ASTORE, scannerVarIndex);

        mv.visitLabel(loopStart);
        mv.visitTryCatchBlock(tryStart, tryEnd, catchHandler, "java/util/InputMismatchException");
        mv.visitLabel(tryStart);

        mv.visitVarInsn(Opcodes.ALOAD, scannerVarIndex);
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/util/Scanner",
                "nextInt",
                "()I",
                false
        );

        mv.visitJumpInsn(Opcodes.GOTO, loopEnd);
        mv.visitLabel(tryEnd);

        mv.visitLabel(catchHandler);
        int exceptionVarIndex = nextVarIndex++;
        mv.visitVarInsn(Opcodes.ASTORE, exceptionVarIndex);

        mv.visitFieldInsn(
                Opcodes.GETSTATIC,
                "java/lang/System",
                "out",
                "Ljava/io/PrintStream;"
        );
        mv.visitLdcInsn("Invalid input. Please enter a valid integer.");
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/io/PrintStream",
                "println",
                "(Ljava/lang/String;)V",
                false
        );

        mv.visitVarInsn(Opcodes.ALOAD, scannerVarIndex);
        mv.visitMethodInsn(
                Opcodes.INVOKEVIRTUAL,
                "java/util/Scanner",
                "next",
                "()Ljava/lang/String;",
                false
        );
        mv.visitInsn(Opcodes.POP);

        mv.visitJumpInsn(Opcodes.GOTO, loopStart);
        mv.visitLabel(loopEnd);
    }
}